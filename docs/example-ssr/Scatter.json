{"main":{"title":"index.svelte","contents":"<script>\n  import { LayerCake, Html } from 'layercake';\n\n  import Scatter from './_components/Scatter.html.svelte';\n  import AxisX from './_components/AxisX.html.svelte';\n  import AxisY from './_components/AxisY.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/points.csv';\n\n  const xKey = 'myX';\n  const yKey = 'myY';\n\n  data.forEach(d => {\n    d[yKey] = +d[yKey];\n  });\n\n  const r = 4.5;\n  const padding = 2.5;\n  const fill = '#fff';\n  const stroke = '#0cf';\n  const strokeWidth = 1.5;\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 100%;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr={true}\n    percentRange={true}\n    padding={{ top: 10, right: 5, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    xPadding={[padding, padding]}\n    yPadding={[padding, padding]}\n    data={data}\n  >\n\n    <Html>\n      <AxisX/>\n      <AxisY/>\n      <Scatter\n        {r}\n        {fill}\n        {stroke}\n        {strokeWidth}\n      />\n    </Html>\n\n  </LayerCake>\n</div>"},"dek":"","components":[{"title":"./_components/Scatter.html.svelte","contents":"<!--\n  @component\n  Generates an HTML scatter plot. This component can also work if the x- or y-scale is ordinal, i.e. it has a `.bandwidth` method. See the [timeplot chart](https://layercake.graphics/example/Timeplot) for an example.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, xScale, yScale } = getContext('LayerCake');\n\n  /** @type {Number} [r=5] – The circle's radius. */\n  export let r = 5;\n\n  /** @type {String} [fill='#0cf'] – The circle's fill color. */\n  export let fill = '#0cf';\n\n  /** @type {String} [stroke='#000'] – The circle's stroke color. */\n  export let stroke = '#000';\n\n  /** @type {Number} [strokeWidth=1] – The circle's stroke width. */\n  export let strokeWidth = 1;\n</script>\n\n<div class=\"scatter-group\">\n  {#each $data as d}\n    <div\n      class=\"circle\"\n      style=\"\n        left: {$xGet(d) + ($xScale.bandwidth ? $xScale.bandwidth() / 2 : 0)}%;\n        top: {$yGet(d) + ($yScale.bandwidth ? $yScale.bandwidth() / 2 : 0)}%;\n        width: {r * 2}px;\n        height: {r * 2}px;\n        background-color: {fill};\n        border: {strokeWidth}px solid {stroke};\n      \"\n    />\n  {/each}\n</div>\n\n<style>\n  .circle {\n    position: absolute;\n    transform: translate(-50%, -50%);\n    border-radius: 50%;\n  }\n</style>"},{"title":"./_components/AxisX.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts.  This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space. */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapTicks=false] – Instead of centering the text on the first and the last items, align them to the edges of the chart. */\n  export let snapTicks = false;\n\n  /** @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [yTick=7] – The distance from the baseline to place each tick value, in pixels. */\n  export let yTick = 7;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n</script>\n\n<div class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i}\n    {#if gridlines !== false}\n      <div class=\"gridline\" style='left:{$xScale(tick)}%;top: 0px;bottom: 0;'></div>\n    {/if}\n    {#if tickMarks === true}\n      <div class=\"tick-mark\" style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;height:6px;bottom: -6px;'></div>\n    {/if}\n    <div\n      class='tick tick-{ i }'\n      style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;top:100%;'>\n      <div\n        class=\"text\"\n        style='top:{(yTick)}px;'>{formatTick(tick)}</div>\n    </div>\n  {/each}\n  {#if baseline === true}\n    <div class=\"baseline\" style='top: 100%;width: 100%;'></div>\n  {/if}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapTicks .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapTicks .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] – Extend lines from the ticks into the chart space */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] – Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Function} [formatTick=d => d] – A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] – If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [xTick=-4] – How far over to position the text marker. */\n  export let xTick = -4;\n\n  /** @type {Number} [yTick=-1] – How far up and down to position the text marker. */\n  export let yTick = -1;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<div class='axis y-axis' style='transform:translate(-{$padding.left}px, 0)'>\n  {#each tickVals as tick, i}\n    <div class='tick tick-{i}' style='top:{$yScale(tick) + (isBandwidth ? $yScale.bandwidth () / 2 : 0)}%;left:{$xRange[0]}%;'>\n      {#if gridlines !== false}\n        <div class=\"gridline\" style='top:0;left:{isBandwidth ? $padding.left : 0}px;right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if baseline !== false && i === 0}\n        <div class=\"gridline baseline\" style='top:0;left:{isBandwidth ? $padding.left : 0};right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if tickMarks === true}\n        <div class=\"tick-mark\" style='top:0;left:{isBandwidth ? $padding.left - 6 : 0}px;width:6px;'></div>\n      {/if}\n      <div\n        class=\"text\"\n        style='\n          top:{yTick}px;\n          left:{isBandwidth ? ($padding.left + xTick - 4) : 0}px;\n          transform: translate({isBandwidth ? '-100%' : 0}, {isBandwidth ? -50 - Math.floor($yScale.bandwidth() / -2) : '-100'}%);\n        '\n      >{formatTick(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 12px;\n    width: 100%;\n    font-weight: 100;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./_data/points.csv","contents":"myX,myY\n1979,7.19\n1980,7.83\n1981,7.24\n1982,7.44\n1983,7.51\n1984,7.1\n1985,6.91\n1986,7.53\n1987,7.47\n1988,7.48\n1989,7.03\n1990,6.23\n1991,6.54\n1992,7.54\n1993,6.5\n1994,7.18\n1995,6.12\n1996,7.87\n1997,6.73\n1998,6.55\n1999,6.23\n2000,6.31\n2001,6.74\n2002,5.95\n2003,6.13\n2004,6.04\n2005,5.56\n2006,5.91\n2007,4.29\n2008,4.72\n2009,5.38\n2010,4.92\n2011,4.61\n2012,3.62\n2013,5.35\n2014,5.28\n2015,4.63\n2016,4.72"}],"jsons":[]}