{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, ScaledSvg, Html, flatten } from 'layercake';\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n  import { format } from 'd3-format';\n\n  import MultiLine from './_components/MultiLine.svelte';\n  import AxisX from './_components/AxisX.percent-range.html.svelte';\n  import AxisY from './_components/AxisY.percent-range.html.svelte';\n  import GroupLabels from './_components/GroupLabels.html.svelte';\n  import SharedTooltip from './_components/SharedTooltip.percent-range.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/fruit.csv';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n  const yKey = 'value';\n  const zKey = 'fruit';\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ffe4b8', '#ffb3c0', '#ff7ac7', '#ff00cc'];\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  /* --------------------------------------------\n   * Create a \"long\" format that is a grouped series of data points\n   * Layer Cake uses this data structure and the key names\n   * set in xKey, yKey and zKey to map your data into each scale.\n   */\n  const dataLong = seriesNames.map(key => {\n    return {\n      [zKey]: key,\n      values: data.map(d => {\n        // Put this in a conditional so that we don't recast the data on second render\n        d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey];\n        return {\n          [yKey]: +d[key],\n          [xKey]: d[xKey],\n          [zKey]: key\n        };\n      })\n    };\n  });\n\n  const formatLabelX = timeFormat('%b. %e');\n  const formatLabelY = d => format(`~s`)(d);\n</script>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr\n    percentRange\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zRange={seriesColors}\n    flatData={flatten(dataLong, 'values')}\n    yDomain={[0, null]}\n    data={dataLong}\n  >\n    <Html>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => d[xKey]).sort((a, b) => a - b)}\n        format={formatLabelX}\n        snapLabels\n        tickMarks\n      />\n      <AxisY format={formatLabelY} />\n    </Html>\n\n    <ScaledSvg>\n      <MultiLine />\n    </ScaledSvg>\n\n    <Html>\n      <GroupLabels />\n      <SharedTooltip formatTitle={formatLabelX} dataset={data} />\n    </Html>\n  </LayerCake>\n</div>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>"},"dek":"A multiline example with a quadtree tooltip. This is an interesting example because the data exists in a few different structures:\n\n1. We're loading data from a \"wide\" format CSV file where each series has its own column name.\n\n   ```\n   [\n     {\n       month: 2015-03-31T22:00:00.000Z,\n       apples: '3840',\n       bananas: '1920',\n       cherries: '960',\n       dates: '400'\n     },\n     {\n       month: 2015-02-28T23:00:00.000Z,\n       apples: '1600',\n       bananas: '1440',\n       cherries: '960',\n       dates: '400'\n     },\n     ...\n   ```\n\n   We need to first turn this into...\n\n2. ...a \"long\" format, where each type of fruit is grouped into its own array and each datapoint is a row. The column name becomes a property on the group whose name we define with the `zKey` variable.\n\n   ```\n   [\n       {\n           \"fruit\": \"apples\",\n           \"values\": [\n               {\n                   \"value\": 3840,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               {\n                   \"value\": 1600,\n                   \"month\": \"2015-02-28T23:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               ...\n           ]\n       },\n       {\n           \"fruit\": \"bananas\",\n           \"values\": [\n               {\n                   \"value\": 1920,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"bananas\"\n               },\n       ...\n   ```\n\n3. We also need a flat, ungrouped array of objects so that Layer Cake can measure the full data extents. This gets passed to the `flatData` prop so the scales know the full domain of the data.\n   ```\n   [\n     { value: 3840, month: 2015-03-31T22:00:00.000Z, fruit: 'apples' },\n     { value: 1600, month: 2015-02-28T23:00:00.000Z, fruit: 'apples' },\n     { value: 640, month: 2015-01-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 320, month: 2014-12-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 1920, month: 2015-03-31T22:00:00.000Z, fruit: 'bananas' },\n     ...\n   ```\n   We're using a regular JavaScript transform to do steps one and two. See the [client-side rendered example](https://layercake.graphics/example/MultiLine) for how to do this with Layer Cake's [groupLonger transform function](https://layercake.graphics/guide#grouplonger).\n","components":[{"title":"./_components/MultiLine.svelte","contents":"<!--\n  @component\n  Generates an SVG multi-series line chart. It expects your data to be an array of objects, each with a `values` key that is an array of data objects.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { line, curveLinear } from 'd3-shape';\n\n  const { data, xGet, yGet, zGet } = getContext('LayerCake');\n\n  /** @type {Function} [curve=curveLinear] - An optional D3 interpolation function. See [d3-shape](https://github.com/d3/d3-shape#curves) for options. Pass this function in uncalled, i.e. without the open-close parentheses. */\n  export let curve = curveLinear;\n\n  $: path = line().x($xGet).y($yGet).curve(curve);\n  // .defined($y)\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path class=\"path-line\" d={path(group.values)} stroke={$zGet(group)}></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./_components/AxisX.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n\n  Although this is marked as a percent-range component, you can also use it with a normal scale with no configuration needed. By default, if you have `percentRange={true}` it will use percentages, otherwise it will use pixels. This makes this component compatible with server-side and client-side rendered charts. Set the `units` prop to either `'%'` or `'px'` to override the default behavior.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xScale, percentRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=6] - The length of the tick mark. */\n  export let tickMarkLength = 6;\n\n  /** @type {Boolean} [baseline=false] â€“ Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapLabels=false] - Instead of centering the text labels on the first and the last items, align them to the edges of the chart. */\n  export let snapLabels = false;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the yRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=0] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 0;\n\n  /** @type {String} units - Whether this component should use percentage or pixel values. If `percentRange={true}` it defaults to `'%'`. Options: `'%'` or `'px'`. */\n  export let units = $percentRange === true ? '%' : 'px';\n\n  $: tickLen = tickMarks === true ? tickMarkLength ?? 6 : 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $xScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($xScale.ticks())\n        : $xScale.ticks(ticks);\n\n  $: halfBand = isBandwidth ? $xScale.bandwidth() / 2 : 0;\n</script>\n\n<div class=\"axis x-axis\" class:snapLabels>\n  {#each tickVals as tick, i (tick)}\n    {@const tickValUnits = $xScale(tick)}\n\n    {#if baseline === true}\n      <div class=\"baseline\" style=\"top:100%; width:100%;\"></div>\n    {/if}\n\n    {#if gridlines === true}\n      <div class=\"gridline\" style:left=\"{tickValUnits}{units}\" style=\"top:0; bottom:0;\"></div>\n    {/if}\n    {#if tickMarks === true}\n      <div\n        class=\"tick-mark\"\n        style:left=\"{tickValUnits + halfBand}{units}\"\n        style:height=\"{tickLen}px\"\n        style:bottom=\"{-tickLen - tickGutter}px\"\n      ></div>\n    {/if}\n    <div\n      class=\"tick tick-{i}\"\n      style:left=\"{tickValUnits + halfBand}{units}\"\n      style=\"top:calc(100% + {tickGutter}px);\"\n    >\n      <div\n        class=\"text\"\n        style:top=\"{tickLen}px\"\n        style:transform=\"translate(calc(-50% + {dx}px), {dy}px)\"\n      >\n        {format(tick)}\n      </div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapLabels .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapLabels .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis. This component is also configured to detect if your y-scale is an ordinal scale. If so, it will place the tickMarks in the middle of the bandwidth.\n\n  Although this is marked as a percent-range component, you can also use it with a normal scale with no configuration needed. By default, if you have `percentRange={true}` it will use percentages, otherwise it will use pixels. This makes this component compatible with server-side and client-side rendered charts. Set the `units` prop to either `'%'` or `'px'` to override the default behavior.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xRange, yScale, percentRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show marks next to the tick label. */\n  export let tickMarks = false;\n\n  /** @type {String} [labelPosition='even'] - Whether the label sits even with its value ('even') or sits on top ('above') the tick mark. Default is 'even'. */\n  export let labelPosition = 'even';\n\n  /** @type {Boolean} [snapBaselineLabel=false] - When labelPosition='even', adjust the lowest label so that it sits above the tick mark. */\n  export let snapBaselineLabel = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=undefined] - The length of the tick mark. If not set, becomes the length of the widest tick. */\n  export let tickMarkLength = undefined;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the xRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=-3] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = -3;\n\n  /** @type {Number} [charPixelWidth=7.25] - Used to calculate the widest label length to offset labels. Adjust if the automatic tick length doesn't look right because you have a bigger font (or just set `tickMarkLength` to a pixel value). */\n  export let charPixelWidth = 7.25;\n\n  /** @type {String} units - Whether this component should use percentage or pixel values. If `percentRange={true}` it defaults to `'%'`. Options: `'%'` or `'px'`. */\n  export let units = $percentRange === true ? '%' : 'px';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $yScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($yScale.ticks())\n        : $yScale.ticks(ticks);\n\n  function calcStringLength(sum, val) {\n    if (val === ',' || val === '.') return sum + charPixelWidth * 0.5;\n    return sum + charPixelWidth;\n  }\n\n  $: tickLen =\n    tickMarks === true\n      ? labelPosition === 'above'\n        ? tickMarkLength ?? widestTickLen\n        : tickMarkLength ?? 6\n      : 0;\n\n  $: widestTickLen = Math.max(\n    10,\n    Math.max(...tickVals.map(d => format(d).toString().split('').reduce(calcStringLength, 0)))\n  );\n\n  $: x1 = -tickGutter - (labelPosition === 'above' ? widestTickLen : tickLen);\n  $: halfBand = isBandwidth ? $yScale.bandwidth() / 2 : 0;\n\n  $: maxTickValUnits = Math.max(...tickVals.map($yScale));\n</script>\n\n<div class=\"axis y-axis\">\n  {#each tickVals as tick, i (tick)}\n    {@const tickValUnits = $yScale(tick)}\n\n    <div\n      class=\"tick tick-{i}\"\n      style=\"left:{$xRange[0]}{units};top:{tickValUnits + halfBand}{units};\"\n    >\n      {#if gridlines === true}\n        <div class=\"gridline\" style=\"top:0;\" style:left=\"{x1}px\" style:right=\"0px\"></div>\n      {/if}\n      {#if tickMarks === true}\n        <div class=\"tick-mark\" style:top=\"0\" style:left=\"{x1}px\" style:width=\"{tickLen}px\"></div>\n      {/if}\n      <div\n        class=\"text\"\n        style:top=\"0\"\n        style:text-align={labelPosition === 'even' ? 'right' : 'left'}\n        style:width=\"{widestTickLen}px\"\n        style:left=\"{-widestTickLen - tickGutter - (labelPosition === 'even' ? tickLen : 0)}px\"\n        style:transform=\"translate({dx + (labelPosition === 'even' ? -3 : 0)}px, calc(-50% + {dy +\n          (labelPosition === 'above' ||\n          (snapBaselineLabel === true && tickValUnits === maxTickValUnits)\n            ? -3\n            : 4)}px))\"\n      >\n        {format(tick)}\n      </div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n    width: 100%;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./_components/GroupLabels.html.svelte","contents":"<!--\n  @component\n  Generates HTML text labels for a nested data structure. It places the label near the y-value of the highest x-valued data point. This is useful for labeling the final point in a multi-series line chart, for example. It expects your data to be an array of objects where each has `values` field that is an array of data objects. It uses the `z` field accessor to pull the text label.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { max } from 'd3-array';\n\n  const { data, x, y, xScale, yScale, xRange, yRange, z } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Title case the first letter\n   */\n  const cap = val => val.replace(/^\\w/, d => d.toUpperCase());\n\n  /* --------------------------------------------\n   * Put the label on the highest value\n   */\n  $: left = values => $xScale(max(values, $x)) / Math.max(...$xRange);\n  $: top = values => $yScale(max(values, $y)) / Math.max(...$yRange);\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"\n      top:{top(group.values) * 100}%;\n      left:{left(group.values) * 100}%;\n    \"\n  >\n    {cap($z(group))}\n  </div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%) translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./_components/SharedTooltip.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates a tooltip that works on multiseries datasets, like multiline charts. It creates a tooltip showing the name of the series and the current value. This version uses percentages so you can use it to render server-side. It finds the nearest data point using the [QuadTree.percent-range.html.svelte](https://layercake.graphics/components/QuadTree.percent-range.html.svelte) component.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { format } from 'd3-format';\n\n  import QuadTree from './QuadTree.percent-range.html.svelte';\n\n  const { data, width, yScale, config } = getContext('LayerCake');\n\n  const commas = format(',');\n  const titleCase = d => d.replace(/^\\w/, w => w.toUpperCase());\n\n  /** @type {Function} [formatTitle=d => d] - A function to format the tooltip title, which is `$config.x`. */\n  export let formatTitle = d => d;\n\n  /** @type {Function} [formatKey=d => titleCase(d)] - A function to format the series name. */\n  export let formatKey = d => titleCase(d);\n\n  /** @type {Function} [formatValue=d => isNaN(+d) ? d : commas(d)] - A function to format the value. */\n  export let formatValue = d => (isNaN(+d) ? d : commas(d));\n\n  /** @type {Number} [offset=-20] - A y-offset from the hover point, in pixels. */\n  export let offset = -20;\n\n  /** @type {Array<Object>|undefined} [dataset] - The dataset to work off ofâ€”defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  const w = 150;\n  const w2 = w / 2;\n\n  /* --------------------------------------------\n   * Sort the keys by the highest value\n   */\n  function sortResult(result) {\n    if (Object.keys(result).length === 0) return [];\n    const rows = Object.keys(result)\n      .filter(d => d !== $config.x)\n      .map(key => {\n        return {\n          key,\n          value: result[key]\n        };\n      })\n      .sort((a, b) => b.value - a.value);\n\n    return rows;\n  }\n</script>\n\n<QuadTree dataset={dataset || $data} y=\"x\" let:x let:y let:visible let:found let:e>\n  {@const foundSorted = sortResult(found)}\n  {#if visible === true}\n    <div style=\"left:{(x / 100) * $width}px;\" class=\"line\"></div>\n    <div\n      class=\"tooltip\"\n      style=\"\n        width:{w}px;\n        display: {visible ? 'block' : 'none'};\n        top:calc({$yScale(foundSorted[0].value)}% + {offset}px);\n        left:{Math.min(Math.max(w2, (x / 100) * $width), $width - w2)}px;\"\n    >\n      <div class=\"title\">{formatTitle(found[$config.x])}</div>\n      {#each foundSorted as row}\n        <div class=\"row\">\n          <span class=\"key\">{formatKey(row.key)}:</span>\n          {formatValue(row.value)}\n        </div>\n      {/each}\n    </div>\n  {/if}\n</QuadTree>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    z-index: 15;\n  }\n  .line {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    border-left: 1px dotted #666;\n    pointer-events: none;\n  }\n  .tooltip,\n  .line {\n    transition:\n      left 250ms ease-out,\n      top 250ms ease-out;\n  }\n  .title {\n    font-weight: bold;\n  }\n  .key {\n    color: #999;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./_components/QuadTree.percent-range.html.svelte","contents":"<!--\n  @component\n  Creates an interaction layer (in HTML) using [d3-quadtree](https://github.com/d3/d3-quadtree) to find the nearest datapoint to the mouse. This component creates a slot that exposes variables `x`, `y`, `found` (the found datapoint), `visible` (a Boolean whether any data was found) and `e` (the event object). This component works with a percent range so the `x` and `y` values coming back will be percentages.\n\n  The quadtree searches across both the x and y dimensions at the same time. But if you want to only search across one, set the `x` and `y` props to the same value. For example, the [shared tooltip component](https://layercake.graphics/components/SharedTooltip.html.svelte) sets `y='x'` since it's nicer behavior to only pick up on the nearest x-value.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  /** @type {String} [x='x'] - The dimension to search across when moving the mouse left and right. */\n  export let x = 'x';\n\n  /** @type {String} [y='y'] - The dimension to search across when moving the mouse up and down. */\n  export let y = 'y';\n\n  /** @type {Number|undefined} [searchRadius] - The number of pixels to search around the mouse's location. This is the third argument passed to [`quadtree.find`](https://github.com/d3/d3-quadtree#quadtree_find) and by default a value of `undefined` means an unlimited range. */\n  export let searchRadius = undefined;\n\n  /** @type {Array<Object>|undefined} [dataset] - The dataset to work off ofâ€”defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem(evt) {\n    e = evt;\n\n    const xLayerKey = `layer${x.toUpperCase()}`;\n    const yLayerKey = `layer${y.toUpperCase()}`;\n\n    const xLayerVal = (evt[xLayerKey] / (x === 'x' ? $width : $height)) * 100;\n    const yLayerVal = (evt[yLayerKey] / (y === 'y' ? $height : $width)) * 100;\n\n    found = finder.find(xLayerVal, yLayerVal, searchRadius) || {};\n\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([\n      [-1, -1],\n      [$width + 1, $height + 1]\n    ])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n</script>\n\n<div\n  class=\"bg\"\n  on:mousemove={findItem}\n  on:mouseout={() => (visible = false)}\n  on:blur={() => (visible = false)}\n  role=\"tooltip\"\n></div>\n<slot x={xGetter(found) || 0} y={yGetter(found) || 0} {found} {visible} {e}></slot>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>"}],"csvs":[{"title":"./_data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}