{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, ScaledSvg, Html, flatten } from 'layercake';\n  import { stack } from 'd3-shape';\n  import { scaleOrdinal } from 'd3-scale';\n  import { format } from 'd3-format';\n  import { timeParse, timeFormat } from 'd3-time-format';\n\n  import AxisX from './_components/AxisX.percent-range.html.svelte';\n  import AxisY from './_components/AxisY.percent-range.html.svelte';\n  import AreaStacked from './_components/AreaStacked.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/fruit.csv';\n\n  const xKey = 'month';\n  const yKey = [0, 1];\n  const zKey = 'key';\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ff00cc', '#ff7ac7', '#ffb3c0', '#ffe4b8'];\n\n  data.forEach(d => {\n    d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey];\n    seriesNames.forEach(name => {\n      d[name] = +d[name];\n    });\n  });\n\n  /* --------------------------------------------\n   * Create a stacked data structure\n   */\n  const stackData = stack()\n    .keys(seriesNames);\n\n  const series = stackData(data);\n\n  const formatLabelX = timeFormat('%b. %-d')\n  const formatLabelY = d => format(`~s`)(d);\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr={true}\n    percentRange={true}\n    padding={{ top: 0, right: 0, bottom: 20, left: 17 }}\n    x={d => d.data[xKey]}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zDomain={seriesNames}\n    zRange={seriesColors}\n    flatData={flatten(series)}\n    data={series}\n  >\n    <Html>\n      <AxisX\n        format={formatLabelX}\n        tickMarks={true}\n      />\n      <AxisY\n        format={formatLabelY}\n      />\n    </Html>\n    <ScaledSvg>\n      <AreaStacked/>\n    </ScaledSvg>\n  </LayerCake>\n</div>"},"dek":"Stack area charts using D3's [stack](https://github.com/d3/d3-shape#stacks) function. Because this will create a nested data structure, we use LayerCake's `flatten` function and the `flatData` option from which we measure the extents.\n","components":[{"title":"./_components/AxisX.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts.  This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=6] - The length of the tick mark. */\n  export let tickMarkLength = 6;\n\n  /** @type {Boolean} [baseline=false] â€“ Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapLabels=false] - Instead of centering the text labels on the first and the last items, align them to the edges of the chart. */\n  export let snapLabels = false;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the yRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=0] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 1;\n\n  $: tickLen = tickMarks === true\n    ? tickMarkLength ?? 6\n    : 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  $: halfBand = isBandwidth ? $xScale.bandwidth() / 2 : 0\n</script>\n\n<div class='axis x-axis' class:snapLabels>\n  {#each tickVals as tick, i (tick)}\n    {@const tickValPx = $xScale(tick)}\n\n    {#if baseline === true}\n      <div class=\"baseline\" style='top:100%; width:100%;'></div>\n    {/if}\n\n    {#if gridlines === true}\n      <div\n        class=\"gridline\"\n        style:left='{tickValPx}%'\n        style='top:0; bottom:0;'></div>\n    {/if}\n    {#if tickMarks === true}\n      <div\n        class=\"tick-mark\"\n        style:left='{tickValPx + halfBand}%'\n        style:height='{tickLen}px'\n        style:bottom='{-tickLen - tickGutter}px'\n      ></div>\n    {/if}\n    <div\n      class='tick tick-{i}'\n      style:left='{tickValPx + halfBand}%'\n      style='top:calc(100% + {tickGutter}px);'>\n      <div\n        class=\"text\"\n        style:top='{tickLen}px'\n        style:transform='translate(calc(-50% + {dx}px), {dy}px)'\n      >{format(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapLabels .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapLabels .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis. This component is also configured to detect if your y-scale is an ordinal scale. If so, it will place the tickMarks in the middle of the bandwidth.\n -->\n <script>\n  import { getContext } from 'svelte';\n\n  const { xRange, yScale, width } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=true] - Show marks next to the tick label. */\n  export let tickMarks = true;\n\n  /** @type {String} [labelPosition='even'] - Whether the label sits even with its value ('even') or sits on top ('above') the tick mark. Default is 'even'. */\n  export let labelPosition = 'even';\n\n  /** @type {Boolean} [snapBaselineLabel=false] - When labelPosition='even', adjust the lowest label so that it sits above the tick mark. */\n  export let snapBaselineLabel = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=undefined] - The length of the tick mark. If not set, becomes the length of the widest tick. */\n  export let tickMarkLength = undefined;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d ;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the xRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=-3] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = -3;\n\n  /** @type {Number} [charPixelWidth=7.25] - Used to calculate the widest label length to offset labels. Adjust if the automatic tick length doesn't look right because you have a bigger font (or just set `tickMarkLength` to a pixel value). */\n  export let charPixelWidth = 7.25;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n\n  function calcStringLength(sum, val) {\n    if (val === ',' || val === '.') return sum + charPixelWidth * 0.5;\n    return sum + charPixelWidth;\n  }\n\n  $: tickLen = tickMarks === true\n    ? labelPosition === 'above'\n      ? tickMarkLength ?? widestTickLen\n      : tickMarkLength ?? 6\n    : 0;\n\n  $: widestTickLen = Math.max(10, Math.max(...tickVals.map(d => format(d).toString().split('').reduce(calcStringLength, 0))));\n\n  $: x1 = -tickGutter - (labelPosition === 'above' ? widestTickLen : tickLen);\n  $: y = isBandwidth ? $yScale.bandwidth() / 2 : 0;\n\n  $: maxTickValPx = Math.max(...tickVals.map($yScale));\n</script>\n\n<div class='axis y-axis'>\n  {#each tickVals as tick, i (tick)}\n    {@const tickValPx = $yScale(tick)}\n\n    <div class='tick tick-{i}' style='left:{$xRange[0]}%;top:{tickValPx}%;'>\n      {#if gridlines === true}\n        <div\n          class=\"gridline\"\n          style=\"top:0;\"\n          style:left='{x1}px'\n          style:right='0px'\n        ></div>\n      {/if}\n      {#if tickMarks === true}\n        <div\n          class=\"tick-mark\"\n          style=\"top:0;\"\n          style:left='{x1}px'\n          style:width='{tickLen}px'\n        ></div>\n      {/if}\n      <div\n        class=\"text\"\n        style:top='{y}px'\n        style:text-align='{labelPosition === 'even' ? 'right' : 'left'}'\n        style:width='{widestTickLen}px'\n        style:left='{-widestTickLen - tickGutter - (labelPosition === 'even' ? tickLen : 0)}px'\n        style:transform='translate({dx + (labelPosition === 'even' ? -3 : 0)}px, calc(-50% + {dy + (labelPosition === 'above' || (snapBaselineLabel === true && tickValPx === maxTickValPx) ? -3 : 4)}px))'\n      >{format(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n    width: 100%;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./_components/AreaStacked.svelte","contents":"<!--\n  @component\n  Generates an SVG area shape using the `area` function from [d3-shape](https://github.com/d3/d3-shape) and sets the color via an ordinal scale in `zScale`. It assumes your data is in a [D3 stack format](https://github.com/d3/d3-shape#stack).\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { area } from 'd3-shape';\n\n  const { data, xGet, yScale, zGet } = getContext('LayerCake');\n\n  $: areaGen = area()\n    .x(d => $xGet(d))\n    .y0(d => $yScale(d[0]))\n    .y1(d => $yScale(d[1]));\n</script>\n\n<g class=\"area-group\">\n  {#each $data as d}\n    <path\n      class='path-area'\n      d='{areaGen(d)}'\n      fill='{$zGet(d)}'\n    ></path>\n  {/each}\n</g>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./_data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}