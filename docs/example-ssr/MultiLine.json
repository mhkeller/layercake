{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, ScaledSvg, Html, flatten } from 'layercake';\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n  import { format } from 'd3-format';\n\n  import MultiLine from './_components/MultiLine.svelte';\n  import AxisX from './_components/AxisX.html.svelte';\n  import AxisY from './_components/AxisY.html.svelte';\n  import GroupLabels from './_components/GroupLabels.html.svelte';\n  import SharedTooltip from './_components/SharedTooltip.percent-range.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/fruit.csv';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n  const yKey = 'value';\n  const zKey = 'fruit';\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ffe4b8', '#ffb3c0', '#ff7ac7', '#ff00cc'];\n\n  const parseDate = timeParse('%Y-%m-%d');\n\n  /* --------------------------------------------\n   * Create a \"long\" format that is a grouped series of data points\n   * Layer Cake uses this data structure and the key names\n   * set in xKey, yKey and zKey to map your data into each scale.\n   */\n  const dataLong = seriesNames.map(key => {\n    return {\n      [zKey]: key,\n      values: data.map(d => {\n        // Put this in a conditional so that we don't recast the data on second render\n        d[xKey] = typeof d[xKey] === 'string' ? parseDate(d[xKey]) : d[xKey];\n        return {\n          [yKey]: +d[key],\n          [xKey]: d[xKey],\n          [zKey]: key\n        };\n      })\n    };\n  });\n\n  const formatTickX = timeFormat('%b. %e');\n  const formatTickY = d => format(`~s`)(d);\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr={true}\n    percentRange={true}\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    zScale={scaleOrdinal()}\n    zRange={seriesColors}\n    flatData={flatten(dataLong, 'values')}\n    yDomain={[0, null]}\n    data={dataLong}\n  >\n    <Html>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => d[xKey]).sort((a, b) => a - b)}\n        formatTick={formatTickX}\n        snapTicks={true}\n        tickMarks={true}\n      />\n      <AxisY\n        baseline={true}\n        formatTick={formatTickY}\n      />\n    </Html>\n\n    <ScaledSvg>\n      <MultiLine/>\n    </ScaledSvg>\n\n    <Html>\n      <GroupLabels/>\n      <SharedTooltip\n        formatTitle={formatTickX}\n        dataset={data}\n      />\n    </Html>\n  </LayerCake>\n</div>"},"dek":"A multiline example with a quadtree tooltip. This is an interesting example because the data exists in a few different structures:\n\n1. We're loading data from a \"wide\" format CSV file  where each series has its own column name.\n   ```\n   [\n     {\n       month: 2015-03-31T22:00:00.000Z,\n       apples: '3840',\n       bananas: '1920',\n       cherries: '960',\n       dates: '400'\n     },\n     {\n       month: 2015-02-28T23:00:00.000Z,\n       apples: '1600',\n       bananas: '1440',\n       cherries: '960',\n       dates: '400'\n     },\n     ...\n   ```\n   We need to first turn this into...\n\n2. ...a \"long\" format, where each type of fruit is grouped into its own array and each datapoint is a row. The column name becomes a property on the group whose name we define with the `zKey` variable.\n   ```\n   [\n       {\n           \"fruit\": \"apples\",\n           \"values\": [\n               {\n                   \"value\": 3840,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               {\n                   \"value\": 1600,\n                   \"month\": \"2015-02-28T23:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               ...\n           ]\n       },\n       {\n           \"fruit\": \"bananas\",\n           \"values\": [\n               {\n                   \"value\": 1920,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"bananas\"\n               },\n       ...\n   ```\n\n3. We also need a flat, ungrouped array of objects so that Layer Cake can measure the full data extents. This gets passed to the `flatData` prop so the scales know the full domain of the data.\n   ```\n   [\n     { value: 3840, month: 2015-03-31T22:00:00.000Z, fruit: 'apples' },\n     { value: 1600, month: 2015-02-28T23:00:00.000Z, fruit: 'apples' },\n     { value: 640, month: 2015-01-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 320, month: 2014-12-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 1920, month: 2015-03-31T22:00:00.000Z, fruit: 'bananas' },\n     ...\n   ```\nWe're using a regular JavaScript transform to do steps one and two. See the [client-side rendered example](https://layercake.graphics/example/MultiLine) for how to do this with Layer Cake's [groupLonger transform function](https://layercake.graphics/guide#grouplonger).\n","components":[{"title":"./_components/MultiLine.svelte","contents":"<!--\n  @component\n  Generates an SVG multi-series line chart. It expects your data to be an array of objects, each with a `values` key that is an array of data objects.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, zGet } = getContext('LayerCake');\n\n  $: path = values => {\n    return 'M' + values\n      .map(d => {\n        return $xGet(d) + ',' + $yGet(d);\n      })\n      .join('L');\n  };\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path\n      class='path-line'\n      d='{path(group.values)}'\n      stroke=\"{$zGet(group)}\"\n    ></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./_components/AxisX.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts.  This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space. */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapTicks=false] - Instead of centering the text on the first and the last items, align them to the edges of the chart. */\n  export let snapTicks = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [yTick=7] - The distance from the baseline to place each tick value, in pixels. */\n  export let yTick = 7;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n</script>\n\n<div class='axis x-axis' class:snapTicks>\n  {#each tickVals as tick, i (tick)}\n    {#if gridlines !== false}\n      <div class=\"gridline\" style='left:{$xScale(tick)}%;top: 0px;bottom: 0;'></div>\n    {/if}\n    {#if tickMarks === true}\n      <div class=\"tick-mark\" style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;height:6px;bottom: -6px;'></div>\n    {/if}\n    <div\n      class='tick tick-{ i }'\n      style='left:{$xScale(tick) + (isBandwidth ? $xScale.bandwidth() / 2 : 0)}%;top:100%;'>\n      <div\n        class=\"text\"\n        style='top:{(yTick)}px;'>{formatTick(tick)}</div>\n    </div>\n  {/each}\n  {#if baseline === true}\n    <div class=\"baseline\" style='top: 100%;width: 100%;'></div>\n  {/if}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapTicks .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapTicks .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [xTick=-4] - How far over to position the text marker. */\n  export let xTick = -4;\n\n  /** @type {Number} [yTick=-1] - How far up and down to position the text marker. */\n  export let yTick = -1;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<div class='axis y-axis' style='transform:translate(-{$padding.left}px, 0)'>\n  {#each tickVals as tick, i (tick)}\n    <div class='tick tick-{i}' style='top:{$yScale(tick) + (isBandwidth ? $yScale.bandwidth () / 2 : 0)}%;left:{$xRange[0]}%;'>\n      {#if gridlines !== false}\n        <div class=\"gridline\" style='top:0;left:{isBandwidth ? $padding.left : 0}px;right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if baseline !== false && i === 0}\n        <div class=\"gridline baseline\" style='top:0;left:{isBandwidth ? $padding.left : 0};right:-{$padding.left + $padding.right}px;'></div>\n      {/if}\n      {#if tickMarks === true}\n        <div class=\"tick-mark\" style='top:0;left:{isBandwidth ? $padding.left - 6 : 0}px;width:6px;'></div>\n      {/if}\n      <div\n        class=\"text\"\n        style='\n          top:{yTick}px;\n          left:{isBandwidth ? ($padding.left + xTick - 4) : 0}px;\n          transform: translate({isBandwidth ? '-100%' : 0}, {isBandwidth ? -50 - Math.floor($yScale.bandwidth() / -2) : '-100'}%);\n        '\n      >{formatTick(tick)}</div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 12px;\n    width: 100%;\n    font-weight: 100;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./_components/GroupLabels.html.svelte","contents":"<!--\n  @component\n  Generates HTML text labels for a nested data structure. It places the label near the y-value of the highest x-valued data point. This is useful for labeling the final point in a multi-series line chart, for example. It expects your data to be an array of objects where each has `values` field that is an array of data objects. It uses the `z` field accessor to pull the text label.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { max } from 'd3-array';\n\n  const { data, x, y, xScale, yScale, xRange, yRange, z } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Title case the first letter\n   */\n  const cap = val => val.replace(/^\\w/, d => d.toUpperCase());\n\n  /* --------------------------------------------\n   * Put the label on the highest value\n   */\n  $: left = values => $xScale(max(values, $x)) /  Math.max(...$xRange);\n  $: top = values => $yScale(max(values, $y)) / Math.max(...$yRange);\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"\n      top:{top(group.values) * 100}%;\n      left:{left(group.values) * 100}%;\n    \"\n  >{cap($z(group))}</div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%)translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./_components/SharedTooltip.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates a tooltip that works on multiseries datasets, like multiline charts. It creates a tooltip showing the name of the series and the current value. This version uses percentages so you can use it to render server-side. It finds the nearest data point using the [QuadTree.percent-range.html.svelte](https://layercake.graphics/components/QuadTree.percent-range.html.svelte) component.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { format } from 'd3-format';\n\n  import QuadTree from './QuadTree.percent-range.html.svelte';\n\n  const { data, width, yScale, config } = getContext('LayerCake');\n\n  const commas = format(',');\n  const titleCase = d => d.replace(/^\\w/, w => w.toUpperCase());\n\n  /** @type {Function} [formatTitle=d => d] - A function to format the tooltip title, which is `$config.x`. */\n  export let formatTitle = d => d;\n\n  /** @type {Function} [formatKey=d => titleCase(d)] - A function to format the series name. */\n  export let formatKey = d => titleCase(d);\n\n  /** @type {Function} [formatValue=d => isNaN(+d) ? d : commas(d)] - A function to format the value. */\n  export let formatValue = d => isNaN(+d) ? d : commas(d);\n\n  /** @type {Number} [offset=-20] - A y-offset from the hover point, in pixels. */\n  export let offset = -20;\n\n  /** @type {Array} [dataset] - The dataset to work off of—defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  const w = 150;\n  const w2 = w / 2;\n  let top = 0;\n\n  /* --------------------------------------------\n   * Sort the keys by the highest value\n   */\n  function sortResult(result) {\n    if (Object.keys(result).length === 0) return [];\n    const rows = Object.keys(result).filter(d => d !== $config.x).map(key => {\n      return {\n        key,\n        value: result[key]\n      };\n    }).sort((a, b) => b.value - a.value);\n\n    return rows;\n  }\n</script>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    z-index: 15;\n  }\n  .line {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    border-left: 1px dotted #666;\n    pointer-events: none;\n  }\n  .tooltip,\n  .line {\n    transition: left 250ms ease-out, top 250ms ease-out;\n  }\n  .title {\n    font-weight: bold;\n  }\n  .key {\n    color: #999;\n  }\n</style>\n\n<QuadTree\n  dataset={dataset || $data}\n  y='x'\n  let:x\n  let:y\n  let:visible\n  let:found\n  let:e\n>\n  {@const foundSorted = sortResult(found)}\n  {#if visible === true}\n    <div\n      style=\"left:{(x / 100) * $width }px;\"\n      class=\"line\"></div>\n    <div\n      class=\"tooltip\"\n      style=\"\n        width:{w}px;\n        display: { visible ? 'block' : 'none' };\n        top:calc({$yScale(foundSorted[0].value)}% + {offset}px);\n        left:{Math.min(Math.max(w2, (x / 100) * $width), $width - w2)}px;\"\n      >\n        <div class=\"title\">{formatTitle(found[$config.x])}</div>\n        {#each foundSorted as row}\n          <div class=\"row\"><span class=\"key\">{formatKey(row.key)}:</span> {formatValue(row.value)}</div>\n        {/each}\n    </div>\n  {/if}\n</QuadTree>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./_components/QuadTree.percent-range.html.svelte","contents":"<!--\n  @component\n  Creates an interaction layer (in HTML) using [d3-quadtree](https://github.com/d3/d3-quadtree) to find the nearest datapoint to the mouse. This component creates a slot that exposes variables `x`, `y`, `found` (the found datapoint), `visible` (a Boolean whether any data was found) and `e` (the event object). This component works with a percent range so the `x` and `y` values coming back will be percentages.\n\n  The quadtree searches across both the x and y dimensions at the same time. But if you want to only search across one, set the `x` and `y` props to the same value. For example, the [shared tooltip component](https://layercake.graphics/components/SharedTooltip.html.svelte) sets `y='x'` since it's nicer behavior to only pick up on the nearest x-value.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  /** @type {String} [x='x'] - The dimension to search across when moving the mouse left and right. */\n  export let x = 'x';\n\n  /** @type {String} [y='y'] - The dimension to search across when moving the mouse up and down. */\n  export let y = 'y';\n\n  /** @type {String} [searchRadius] - The number of pixels to search around the mouse's location. This is the third argument passed to [`quadtree.find`](https://github.com/d3/d3-quadtree#quadtree_find) and by default a value of `undefined` means an unlimited range. */\n  export let searchRadius = undefined;\n\n  /** @type {Array} [dataset] - The dataset to work off of—defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem (evt) {\n    e = evt;\n\n    const xLayerKey = `layer${x.toUpperCase()}`;\n    const yLayerKey = `layer${y.toUpperCase()}`;\n\n    const xLayerVal = (evt[xLayerKey] / (x === 'x' ? $width : $height)) * 100;\n    const yLayerVal = (evt[yLayerKey] / (y === 'y' ? $height : $width)) * 100;\n\n    found = finder.find(xLayerVal, yLayerVal, searchRadius) || {};\n\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([[-1, -1], [$width + 1, $height + 1]])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n</script>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>\n\n<div\n  class=\"bg\"\n  on:mousemove=\"{findItem}\"\n  on:mouseout=\"{() => visible = false}\"\n  on:blur=\"{() => visible = false}\"\n></div>\n<slot\n  x={xGetter(found) || 0}\n  y={yGetter(found) || 0}\n  {found}\n  {visible}\n  {e}\n></slot>"}],"csvs":[{"title":"./_data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}