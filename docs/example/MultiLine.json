{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, Svg, Html, groupLonger, flatten } from 'layercake';\n\n  import { scaleOrdinal } from 'd3-scale';\n  import { timeParse, timeFormat } from 'd3-time-format';\n  import { format } from 'd3-format';\n\n  import MultiLine from './_components/MultiLine.svelte';\n  import AxisX from './_components/AxisX.svelte';\n  import AxisY from './_components/AxisY.svelte';\n  import Labels from './_components/GroupLabels.html.svelte';\n  import SharedTooltip from './_components/SharedTooltip.html.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/fruit.csv';\n\n  /* --------------------------------------------\n   * Set what is our x key to separate it from the other series\n   */\n  const xKey = 'month';\n  const yKey = 'value';\n  const zKey = 'fruit';\n\n  const xKeyCast = timeParse('%Y-%m-%d');\n\n  const seriesNames = Object.keys(data[0]).filter(d => d !== xKey);\n  const seriesColors = ['#ffe4b8', '#ffb3c0', '#ff7ac7', '#ff00cc'];\n\n  /* --------------------------------------------\n   * Cast values\n   */\n  data.forEach(d => {\n    d[xKey] = typeof d[xKey] === 'string' ? xKeyCast(d[xKey]) : d[xKey];\n\n    seriesNames.forEach(name => {\n      d[name] = +d[name];\n    });\n  });\n\n  const formatLabelX = timeFormat('%b. %e');\n  const formatLabelY = d => format(`~s`)(d);\n\n  const groupedData = groupLonger(data, seriesNames, {\n    groupTo: zKey,\n    valueTo: yKey\n  });\n</script>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 7, right: 10, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    z={zKey}\n    yDomain={[0, null]}\n    zScale={scaleOrdinal()}\n    zRange={seriesColors}\n    flatData={flatten(groupedData, 'values')}\n    data={groupedData}\n  >\n    <Svg>\n      <AxisX\n        gridlines={false}\n        ticks={data.map(d => d[xKey]).sort((a, b) => a - b)}\n        format={formatLabelX}\n        snapLabels\n        tickMarks\n      />\n      <AxisY ticks={4} format={formatLabelY} />\n      <MultiLine />\n    </Svg>\n\n    <Html>\n      <Labels />\n      <SharedTooltip formatTitle={formatLabelX} dataset={data} />\n    </Html>\n  </LayerCake>\n</div>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>"},"dek":"A multiline example with a quadtree tooltip. This is an interesting example because the data exists in a few different structures:\n\n1. We're loading data from a \"wide\" format CSV file where each series has its own column name.\n\n   ```\n   [\n     {\n       month: 2015-03-31T22:00:00.000Z,\n       apples: '3840',\n       bananas: '1920',\n       cherries: '960',\n       dates: '400'\n     },\n     {\n       month: 2015-02-28T23:00:00.000Z,\n       apples: '1600',\n       bananas: '1440',\n       cherries: '960',\n       dates: '400'\n     },\n     ...\n   ```\n\n   We need to first turn this into...\n\n2. ...a \"long\" format, where each type of fruit is grouped into its own array and each datapoint is a row. The column name becomes a property on the group whose name we define with the `zKey` variable.\n\n   ```\n   [\n       {\n           \"fruit\": \"apples\",\n           \"values\": [\n               {\n                   \"value\": 3840,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               {\n                   \"value\": 1600,\n                   \"month\": \"2015-02-28T23:00:00.000Z\",\n                   \"fruit\": \"apples\"\n               },\n               ...\n           ]\n       },\n       {\n           \"fruit\": \"bananas\",\n           \"values\": [\n               {\n                   \"value\": 1920,\n                   \"month\": \"2015-03-31T22:00:00.000Z\",\n                   \"fruit\": \"bananas\"\n               },\n       ...\n   ```\n\n3. We also need a flat, ungrouped array of objects so that Layer Cake can measure the full data extents. This gets passed to the `flatData` prop so the scales know the full domain of the data.\n   ```\n   [\n     { value: 3840, month: 2015-03-31T22:00:00.000Z, fruit: 'apples' },\n     { value: 1600, month: 2015-02-28T23:00:00.000Z, fruit: 'apples' },\n     { value: 640, month: 2015-01-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 320, month: 2014-12-31T23:00:00.000Z, fruit: 'apples' },\n     { value: 1920, month: 2015-03-31T22:00:00.000Z, fruit: 'bananas' },\n     ...\n   ```\n\nWe're using Layer Cake's [groupLonger transform function](/guide#grouplonger) to do steps one and two. See the [server-side rendered example](/example-ssr/MultiLine) for a regular JavaScript transform.\n","components":[{"title":"./_components/MultiLine.svelte","contents":"<!--\n  @component\n  Generates an SVG multi-series line chart. It expects your data to be an array of objects, each with a `values` key that is an array of data objects.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { line, curveLinear } from 'd3-shape';\n\n  const { data, xGet, yGet, zGet } = getContext('LayerCake');\n\n  /** @type {Function} [curve=curveLinear] - An optional D3 interpolation function. See [d3-shape](https://github.com/d3/d3-shape#curves) for options. Pass this function in uncalled, i.e. without the open-close parentheses. */\n  export let curve = curveLinear;\n\n  $: path = line().x($xGet).y($yGet).curve(curve);\n  // .defined($y)\n</script>\n\n<g class=\"line-group\">\n  {#each $data as group}\n    <path class=\"path-line\" d={path(group.values)} stroke={$zGet(group)}></path>\n  {/each}\n</g>\n\n<style>\n  .path-line {\n    fill: none;\n    stroke-linejoin: round;\n    stroke-linecap: round;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./_components/AxisX.svelte","contents":"<!--\n  @component\n  Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=6] - The length of the tick mark. */\n  export let tickMarkLength = 6;\n\n  /** @type {Boolean} [baseline=false] â€“ Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapLabels=false] - Instead of centering the text labels on the first and the last items, align them to the edges of the chart. */\n  export let snapLabels = false;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the yRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=12] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 12;\n\n  function textAnchor(i, sl) {\n    if (sl === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n\n  $: tickLen = tickMarks === true ? tickMarkLength ?? 6 : 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $xScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($xScale.ticks())\n        : $xScale.ticks(ticks);\n\n  $: halfBand = isBandwidth ? $xScale.bandwidth() / 2 : 0;\n</script>\n\n<g class=\"axis x-axis\" class:snapLabels>\n  {#each tickVals as tick, i (tick)}\n    {#if baseline === true}\n      <line class=\"baseline\" y1={$height} y2={$height} x1=\"0\" x2={$width} />\n    {/if}\n\n    <g class=\"tick tick-{i}\" transform=\"translate({$xScale(tick)},{Math.max(...$yRange)})\">\n      {#if gridlines === true}\n        <line class=\"gridline\" x1={halfBand} x2={halfBand} y1={-$height} y2=\"0\" />\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class=\"tick-mark\"\n          x1={halfBand}\n          x2={halfBand}\n          y1={tickGutter}\n          y2={tickGutter + tickLen}\n        />\n      {/if}\n      <text x={halfBand} y={tickGutter + tickLen} {dx} {dy} text-anchor={textAnchor(i, snapLabels)}\n        >{format(tick)}</text\n      >\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: 11px;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapLabels .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapLabels .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./_components/AxisY.svelte","contents":"<!--\n  @component\n  Generates an SVG y-axis. This component is also configured to detect if your y-scale is an ordinal scale. If so, it will place the tickMarks in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xRange, yScale, width } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show marks next to the tick label. */\n  export let tickMarks = false;\n\n  /** @type {String} [labelPosition='even'] - Whether the label sits even with its value ('even') or sits on top ('above') the tick mark. Default is 'even'. */\n  export let labelPosition = 'even';\n\n  /** @type {Boolean} [snapBaselineLabel=false] - When labelPosition='even', adjust the lowest label so that it sits above the tick mark. */\n  export let snapBaselineLabel = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=undefined] - The length of the tick mark. If not set, becomes the length of the widest tick. */\n  export let tickMarkLength = undefined;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the xRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=0] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 0;\n\n  /** @type {Number} [charPixelWidth=7.25] - Used to calculate the widest label length to offset labels. Adjust if the automatic tick length doesn't look right because you have a bigger font (or just set `tickMarkLength` to a pixel value). */\n  export let charPixelWidth = 7.25;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $yScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($yScale.ticks())\n        : $yScale.ticks(ticks);\n\n  function calcStringLength(sum, val) {\n    if (val === ',' || val === '.') return sum + charPixelWidth * 0.5;\n    return sum + charPixelWidth;\n  }\n\n  $: tickLen =\n    tickMarks === true\n      ? labelPosition === 'above'\n        ? tickMarkLength ?? widestTickLen\n        : tickMarkLength ?? 6\n      : 0;\n\n  $: widestTickLen = Math.max(\n    10,\n    Math.max(...tickVals.map(d => format(d).toString().split('').reduce(calcStringLength, 0)))\n  );\n\n  $: x1 = -tickGutter - (labelPosition === 'above' ? widestTickLen : tickLen);\n  $: y = isBandwidth ? $yScale.bandwidth() / 2 : 0;\n\n  $: maxTickValPx = Math.max(...tickVals.map($yScale));\n</script>\n\n<g class=\"axis y-axis\">\n  {#each tickVals as tick (tick)}\n    {@const tickValPx = $yScale(tick)}\n    <g class=\"tick tick-{tick}\" transform=\"translate({$xRange[0]}, {tickValPx})\">\n      {#if gridlines === true}\n        <line class=\"gridline\" {x1} x2={$width} y1={y} y2={y}></line>\n      {/if}\n      {#if tickMarks === true}\n        <line class=\"tick-mark\" {x1} x2={x1 + tickLen} y1={y} y2={y}></line>\n      {/if}\n      <text\n        x={x1}\n        {y}\n        dx={dx + (labelPosition === 'even' ? -3 : 0)}\n        text-anchor={labelPosition === 'above' ? 'start' : 'end'}\n        dy={dy +\n          (labelPosition === 'above' || (snapBaselineLabel === true && tickValPx === maxTickValPx)\n            ? -3\n            : 4)}>{format(tick)}</text\n      >\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: 11px;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"},{"title":"./_components/GroupLabels.html.svelte","contents":"<!--\n  @component\n  Generates HTML text labels for a nested data structure. It places the label near the y-value of the highest x-valued data point. This is useful for labeling the final point in a multi-series line chart, for example. It expects your data to be an array of objects where each has `values` field that is an array of data objects. It uses the `z` field accessor to pull the text label.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { max } from 'd3-array';\n\n  const { data, x, y, xScale, yScale, xRange, yRange, z } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Title case the first letter\n   */\n  const cap = val => val.replace(/^\\w/, d => d.toUpperCase());\n\n  /* --------------------------------------------\n   * Put the label on the highest value\n   */\n  $: left = values => $xScale(max(values, $x)) / Math.max(...$xRange);\n  $: top = values => $yScale(max(values, $y)) / Math.max(...$yRange);\n</script>\n\n{#each $data as group}\n  <div\n    class=\"label\"\n    style=\"\n      top:{top(group.values) * 100}%;\n      left:{left(group.values) * 100}%;\n    \"\n  >\n    {cap($z(group))}\n  </div>\n{/each}\n\n<style>\n  .label {\n    position: absolute;\n    transform: translate(-100%, -100%) translateY(1px);\n    font-size: 13px;\n  }\n</style>"},{"title":"./_components/SharedTooltip.html.svelte","contents":"<!--\n  @component\n  Generates a tooltip that works on multiseries datasets, like multiline charts. It creates a tooltip showing the name of the series and the current value. It finds the nearest data point using the [QuadTree.html.svelte](https://layercake.graphics/components/QuadTree.html.svelte) component.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { format } from 'd3-format';\n\n  import QuadTree from './QuadTree.html.svelte';\n\n  const { data, width, yScale, config } = getContext('LayerCake');\n\n  const commas = format(',');\n  const titleCase = d => d.replace(/^\\w/, w => w.toUpperCase());\n\n  /** @type {Function} [formatTitle=d => d] - A function to format the tooltip title, which is `$config.x`. */\n  export let formatTitle = d => d;\n\n  /** @type {Function} [formatValue=d => isNaN(+d) ? d : commas(d)] - A function to format the value. */\n  export let formatValue = d => (isNaN(+d) ? d : commas(d));\n\n  /** @type {Function} [formatKey=d => titleCase(d)] - A function to format the series name. */\n  export let formatKey = d => titleCase(d);\n\n  /** @type {Number} [offset=-20] - A y-offset from the hover point, in pixels. */\n  export let offset = -20;\n\n  /** @type {Array<Object>|undefined} [dataset] - The dataset to work off ofâ€”defaults to $data if left unset. You can pass something custom in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  const w = 150;\n  const w2 = w / 2;\n\n  /* --------------------------------------------\n   * Sort the keys by the highest value\n   */\n  function sortResult(result) {\n    if (Object.keys(result).length === 0) return [];\n    const rows = Object.keys(result)\n      .filter(d => d !== $config.x)\n      .map(key => {\n        return {\n          key,\n          value: result[key]\n        };\n      })\n      .sort((a, b) => b.value - a.value);\n\n    return rows;\n  }\n</script>\n\n<QuadTree dataset={dataset || $data} y=\"x\" let:x let:y let:visible let:found let:e>\n  {@const foundSorted = sortResult(found)}\n  {#if visible === true}\n    <div style=\"left:{x}px;\" class=\"line\"></div>\n    <div\n      class=\"tooltip\"\n      style=\"\n        width:{w}px;\n        display: {visible ? 'block' : 'none'};\n        top:{$yScale(foundSorted[0].value) + offset}px;\n        left:{Math.min(Math.max(w2, x), $width - w2)}px;\"\n    >\n      <div class=\"title\">{formatTitle(found[$config.x])}</div>\n      {#each foundSorted as row}\n        <div class=\"row\">\n          <span class=\"key\">{formatKey(row.key)}:</span>\n          {formatValue(row.value)}\n        </div>\n      {/each}\n    </div>\n  {/if}\n</QuadTree>\n\n<style>\n  .tooltip {\n    position: absolute;\n    font-size: 13px;\n    pointer-events: none;\n    border: 1px solid #ccc;\n    background: rgba(255, 255, 255, 0.85);\n    transform: translate(-50%, -100%);\n    padding: 5px;\n    z-index: 15;\n    pointer-events: none;\n  }\n  .line {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    border-left: 1px dotted #666;\n    pointer-events: none;\n  }\n  .tooltip,\n  .line {\n    transition:\n      left 250ms ease-out,\n      top 250ms ease-out;\n  }\n  .title {\n    font-weight: bold;\n  }\n  .key {\n    color: #999;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[{"title":"./_components/QuadTree.html.svelte","contents":"<!--\n  @component\n  Creates an interaction layer (in HTML) using [d3-quadtree](https://github.com/d3/d3-quadtree) to find the nearest datapoint to the mouse. This component creates a slot that exposes variables `x`, `y`, `found` (the found datapoint), `visible` (a Boolean whether any data was found) and `e` (the event object).\n\n  The quadtree searches across both the x and y dimensions at the same time. But if you want to only search across one, set the `x` and `y` props to the same value. For example, the [shared tooltip component](https://layercake.graphics/components/SharedTooltip.html.svelte) sets `y='x'` since it's nicer behavior to only pick up on the nearest x-value.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { quadtree } from 'd3-quadtree';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  let visible = false;\n  let found = {};\n  let e = {};\n\n  /** @type {String} [x='x'] â€“ The dimension to search across when moving the mouse left and right. */\n  export let x = 'x';\n\n  /** @type {String} [y='y'] â€“ The dimension to search across when moving the mouse up and down. */\n  export let y = 'y';\n\n  /** @type {Number|undefined} [searchRadius] â€“ The number of pixels to search around the mouse's location. This is the third argument passed to [`quadtree.find`](https://github.com/d3/d3-quadtree#quadtree_find) and by default a value of `undefined` means an unlimited range. */\n  export let searchRadius = undefined;\n\n  /** @type {Array<Object>|undefined} [dataset] â€“ The dataset to work off ofâ€”defaults to $data if left unset. You can pass override the default here in here in case you don't want to use the main data or it's in a strange format. */\n  export let dataset = undefined;\n\n  $: xGetter = x === 'x' ? $xGet : $yGet;\n  $: yGetter = y === 'y' ? $yGet : $xGet;\n\n  function findItem(evt) {\n    e = evt;\n\n    const xLayerKey = `layer${x.toUpperCase()}`;\n    const yLayerKey = `layer${y.toUpperCase()}`;\n\n    found = finder.find(evt[xLayerKey], evt[yLayerKey], searchRadius) || {};\n    visible = Object.keys(found).length > 0;\n  }\n\n  $: finder = quadtree()\n    .extent([\n      [-1, -1],\n      [$width + 1, $height + 1]\n    ])\n    .x(xGetter)\n    .y(yGetter)\n    .addAll(dataset || $data);\n</script>\n\n<div\n  class=\"bg\"\n  on:mousemove={findItem}\n  on:mouseout={() => (visible = false)}\n  on:blur={() => (visible = false)}\n  role=\"tooltip\"\n></div>\n<slot x={xGetter(found) || 0} y={yGetter(found) || 0} {found} {visible} {e}></slot>\n\n<style>\n  .bg {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n</style>"}],"csvs":[{"title":"./_data/fruit.csv","contents":"month,apples,bananas,cherries,dates\n2015-04-01,3840,1920,960,400\n2015-03-01,1600,1440,960,400\n2015-02-01,640,960,640,400\n2015-01-01,320,480,640,400"}],"jsons":[]}