{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, Svg, Canvas } from 'layercake';\n\n  import ScatterSvg from './_components/Scatter.svg.svelte';\n  import ScatterCanvas from './_components/Scatter.canvas.svelte';\n  import Voronoi from './_components/Voronoi.svelte';\n  import AxisX from './_components/AxisX.svelte';\n  import AxisY from './_components/AxisY.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/points.csv';\n\n  const xKey = 'myX';\n  const yKey = 'myY';\n\n  data.forEach(d => {\n    d[yKey] = +d[yKey];\n  });\n\n  const r = 3;\n  const padding = 10;\n  const color = '#fff';\n\n  function logEvent(d) {\n    console.log('dispatched event', d, d.detail);\n  }\n</script>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 10, right: 5, bottom: 20, left: 25 }}\n    x={xKey}\n    y={yKey}\n    xPadding={[padding, padding]}\n    yPadding={[padding, padding]}\n    {data}\n  >\n    <Svg>\n      <AxisX gridlines={false} />\n      <AxisY gridlines={false} ticks={4} />\n    </Svg>\n\n    <Canvas>\n      <ScatterCanvas r={r * 1.5} fill=\"#0cf\" />\n    </Canvas>\n\n    <Svg>\n      <ScatterSvg {r} fill={color} />\n      <Voronoi stroke=\"#333\" on:voronoi-mouseover={logEvent} />\n    </Svg>\n  </LayerCake>\n</div>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>"},"dek":"","components":[{"title":"./_components/Scatter.svg.svelte","contents":"<!--\n  @component\n  Generates an SVG scatter plot. This component can also work if the x- or y-scale is ordinal, i.e. it has a `.bandwidth` method. See the [timeplot chart](https://layercake.graphics/example/Timeplot) for an example.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, xScale, yScale } = getContext('LayerCake');\n\n  /** @type {Number} [r=5] – The circle's radius. */\n  export let r = 5;\n\n  /** @type {String} [fill='#0cf'] – The circle's fill color. */\n  export let fill = '#0cf';\n\n  /** @type {String} [stroke='#000'] – The circle's stroke color. */\n  export let stroke = '#000';\n\n  /** @type {Number} [strokeWidth=0] – The circle's stroke width. */\n  export let strokeWidth = 0;\n</script>\n\n<g class=\"scatter-group\">\n  {#each $data as d}\n    <circle\n      cx={$xGet(d) + ($xScale.bandwidth ? $xScale.bandwidth() / 2 : 0)}\n      cy={$yGet(d) + ($yScale.bandwidth ? $yScale.bandwidth() / 2 : 0)}\n      {r}\n      {fill}\n      {stroke}\n      stroke-width={strokeWidth}\n    />\n  {/each}\n</g>"},{"title":"./_components/Scatter.canvas.svelte","contents":"<!--\n  @component\n  Generates a canvas scatter plot.\n -->\n<script>\n  import { getContext } from 'svelte';\n  import { scaleCanvas } from 'layercake';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  const { ctx } = getContext('canvas');\n\n  /** @type {Number} [r=5] - The circle's radius. */\n  export let r = 5;\n\n  /** @type {String} [fill='#0cf'] - The circle's fill color. */\n  export let fill = '#0cf';\n\n  /** @type {String} [stroke='#000'] - The circle's stroke color. */\n  export let stroke = '#000';\n\n  /** @type {Number} [strokeWidth=1] - The circle's stroke width. */\n  export let strokeWidth = 1;\n\n  $: {\n    if ($ctx) {\n      /* --------------------------------------------\n       * If you were to have multiple canvas layers\n       * maybe for some artistic layering purposes\n       * put these reset functions in the first layer, not each one\n       * since they should only run once per update\n       */\n      scaleCanvas($ctx, $width, $height);\n      $ctx.clearRect(0, 0, $width, $height);\n\n      /* --------------------------------------------\n       * Draw our scatterplot\n       */\n      $data.forEach(d => {\n        $ctx.beginPath();\n        $ctx.arc($xGet(d), $yGet(d), r, 0, 2 * Math.PI, false);\n        $ctx.lineWidth = strokeWidth;\n        $ctx.strokeStyle = stroke;\n        $ctx.stroke();\n        $ctx.fillStyle = fill;\n        $ctx.fill();\n      });\n    }\n  }\n</script>"},{"title":"./_components/Voronoi.svelte","contents":"<!--\n  @component\n  Generates a voronoi layer using [d3-delauney](https://github.com/d3/d3-delauney).\n -->\n<script>\n  import { getContext, createEventDispatcher } from 'svelte';\n  import { uniques } from 'layercake';\n  import { Delaunay } from 'd3-delaunay';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  /** @type {String|undefined} [stroke] – An optional stroke color, which is likely only useful for testing to make sure the shapes drew correctly. */\n  export let stroke = undefined;\n\n  let dispatcher = createEventDispatcher();\n\n  function log(point) {\n    console.log(point, point.data);\n    dispatcher('voronoi-mouseover', point);\n  }\n\n  $: points = $data.map(d => {\n    const point = [$xGet(d), $yGet(d)];\n    point.data = d;\n    return point;\n  });\n\n  $: uniquePoints = uniques(points, d => d.join(), false);\n\n  $: voronoi = Delaunay.from(uniquePoints).voronoi([0, 0, $width, $height]);\n</script>\n\n{#each uniquePoints as point, i}\n  <path\n    style=\"stroke: {stroke}\"\n    class=\"voronoi-cell\"\n    d={voronoi.renderCell(i)}\n    on:mouseover={() => {\n      log(point);\n    }}\n    on:focus={() => {\n      log(point);\n    }}\n    role=\"tooltip\"\n  ></path>\n{/each}\n\n<style>\n  .voronoi-cell {\n    fill: none;\n    stroke: none;\n    pointer-events: all;\n    outline: none;\n  }\n\n  /* Useful to testing but you'll want to disable this for production */\n  .voronoi-cell:hover {\n    stroke: #333 !important;\n    stroke-width: 3px;\n  }\n</style>"},{"title":"./_components/AxisX.svelte","contents":"<!--\n  @component\n  Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  /** @type {boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=6] - The length of the tick mark. */\n  export let tickMarkLength = 6;\n\n  /** @type {boolean} [baseline=false] – Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {boolean} [snapLabels=false] - Instead of centering the text labels on the first and the last items, align them to the edges of the chart. */\n  export let snapLabels = false;\n\n  /** @type {(d: any) => string} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array<any>|Function|undefined} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the yRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=12] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 12;\n\n  /**@param {Number} i\n   * @param {boolean} sl */\n  function textAnchor(i, sl) {\n    if (sl === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n\n  $: tickLen = tickMarks === true ? tickMarkLength ?? 6 : 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  /** @type {Array<any>} */\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $xScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($xScale.ticks())\n        : $xScale.ticks(ticks);\n\n  $: halfBand = isBandwidth ? $xScale.bandwidth() / 2 : 0;\n</script>\n\n<g class=\"axis x-axis\" class:snapLabels>\n  {#each tickVals as tick, i (tick)}\n    {#if baseline === true}\n      <line class=\"baseline\" y1={$height} y2={$height} x1=\"0\" x2={$width} />\n    {/if}\n\n    <g class=\"tick tick-{i}\" transform=\"translate({$xScale(tick)},{Math.max(...$yRange)})\">\n      {#if gridlines === true}\n        <line class=\"gridline\" x1={halfBand} x2={halfBand} y1={-$height} y2=\"0\" />\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class=\"tick-mark\"\n          x1={halfBand}\n          x2={halfBand}\n          y1={tickGutter}\n          y2={tickGutter + tickLen}\n        />\n      {/if}\n      <text x={halfBand} y={tickGutter + tickLen} {dx} {dy} text-anchor={textAnchor(i, snapLabels)}\n        >{format(tick)}</text\n      >\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: 11px;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapLabels .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapLabels .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./_components/AxisY.svelte","contents":"<!--\n  @component\n  Generates an SVG y-axis. This component is also configured to detect if your y-scale is an ordinal scale. If so, it will place the tickMarks in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xRange, yScale, width } = getContext('LayerCake');\n\n  /** @type {boolean} [tickMarks=false] - Show marks next to the tick label. */\n  export let tickMarks = false;\n\n  /** @type {String} [labelPosition='even'] - Whether the label sits even with its value ('even') or sits on top ('above') the tick mark. Default is 'even'. */\n  export let labelPosition = 'even';\n\n  /** @type {boolean} [snapBaselineLabel=false] - When labelPosition='even', adjust the lowest label so that it sits above the tick mark. */\n  export let snapBaselineLabel = false;\n\n  /** @type {boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number|undefined} [tickMarkLength=undefined] - The length of the tick mark. If not set, becomes the length of the widest tick. */\n  export let tickMarkLength = undefined;\n\n  /** @type {(d: any) => string} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array<any>|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the xRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=0] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 0;\n\n  /** @type {Number} [charPixelWidth=7.25] - Used to calculate the widest label length to offset labels. Adjust if the automatic tick length doesn't look right because you have a bigger font (or just set `tickMarkLength` to a pixel value). */\n  export let charPixelWidth = 7.25;\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  /** @type {Array<any>} */\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $yScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($yScale.ticks())\n        : $yScale.ticks(ticks);\n\n  /** @param {Number} sum\n   *  @param {String} val */\n  function calcStringLength(sum, val) {\n    if (val === ',' || val === '.') return sum + charPixelWidth * 0.5;\n    return sum + charPixelWidth;\n  }\n\n  $: tickLen =\n    tickMarks === true\n      ? labelPosition === 'above'\n        ? tickMarkLength ?? widestTickLen\n        : tickMarkLength ?? 6\n      : 0;\n\n  $: widestTickLen = Math.max(\n    10,\n    Math.max(...tickVals.map(d => format(d).toString().split('').reduce(calcStringLength, 0)))\n  );\n\n  $: x1 = -tickGutter - (labelPosition === 'above' ? widestTickLen : tickLen);\n  $: y = isBandwidth ? $yScale.bandwidth() / 2 : 0;\n\n  $: maxTickValPx = Math.max(...tickVals.map($yScale));\n</script>\n\n<g class=\"axis y-axis\">\n  {#each tickVals as tick (tick)}\n    {@const tickValPx = $yScale(tick)}\n    <g class=\"tick tick-{tick}\" transform=\"translate({$xRange[0]}, {tickValPx})\">\n      {#if gridlines === true}\n        <line class=\"gridline\" {x1} x2={$width} y1={y} y2={y}></line>\n      {/if}\n      {#if tickMarks === true}\n        <line class=\"tick-mark\" {x1} x2={x1 + tickLen} y1={y} y2={y}></line>\n      {/if}\n      <text\n        x={x1}\n        {y}\n        dx={dx + (labelPosition === 'even' ? -3 : 0)}\n        text-anchor={labelPosition === 'above' ? 'start' : 'end'}\n        dy={dy +\n          (labelPosition === 'above' || (snapBaselineLabel === true && tickValPx === maxTickValPx)\n            ? -3\n            : 4)}>{format(tick)}</text\n      >\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: 11px;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./_data/points.csv","contents":"myX,myY\n1979,7.19\n1980,7.83\n1981,7.24\n1982,7.44\n1983,7.51\n1984,7.1\n1985,6.91\n1986,7.53\n1987,7.47\n1988,7.48\n1989,7.03\n1990,6.23\n1991,6.54\n1992,7.54\n1993,6.5\n1994,7.18\n1995,6.12\n1996,7.87\n1997,6.73\n1998,6.55\n1999,6.23\n2000,6.31\n2001,6.74\n2002,5.95\n2003,6.13\n2004,6.04\n2005,5.56\n2006,5.91\n2007,4.29\n2008,4.72\n2009,5.38\n2010,4.92\n2011,4.61\n2012,3.62\n2013,5.35\n2014,5.28\n2015,4.63\n2016,4.72"}],"jsons":[]}