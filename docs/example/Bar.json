{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, Svg } from 'layercake';\n  import { scaleBand } from 'd3-scale';\n\n  import Bar from './_components/Bar.svelte';\n  import AxisX from './_components/AxisX.svelte';\n  import AxisY from './_components/AxisY.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/groups.csv';\n\n  const xKey = 'value';\n  const yKey = 'year';\n\n  data.forEach(d => {\n    d[xKey] = +d[xKey];\n  });\n</script>\n\n<style>\n  /*\n    The wrapper div needs to have an explicit width and height in CSS.\n    It can also be a flexbox child or CSS grid element.\n    The point being it needs dimensions since the <LayerCake> element will\n    expand to fill it.\n  */\n  .chart-container {\n    width: 100%;\n    height: 250px;\n  }\n</style>\n\n<div class=\"chart-container\">\n  <LayerCake\n    padding={{ top: 0, bottom: 20, left: 35 }}\n    x={xKey}\n    y={yKey}\n    yScale={scaleBand().paddingInner([0.05])}\n    xDomain={[0, null]}\n    data={data}\n  >\n    <Svg>\n      <AxisX\n        gridlines={true}\n        baseline={true}\n        snapTicks={true}\n      />\n      <AxisY\n        gridlines={false}\n      />\n      <Bar/>\n    </Svg>\n  </LayerCake>\n</div>"},"dek":"Since we want an ordinal y-axis and Layer Cake defaults to a linear scale, pass in a custom scale to `yScale` with a few formatting options. Set the x-scale to always start at `0` so you don't show misleading differences between groups.\n","components":[{"title":"./_components/Bar.svelte","contents":"<!--\n  @component\n  Generates an SVG bar chart.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, xScale, yScale } = getContext('LayerCake');\n\n  /** @type {String} [fill='#00bbff'] - The shape's fill color. This is technically optional because it comes with a default value but you'll likely want to replace it with your own color. */\n  export let fill = '#00bbff';\n</script>\n\n<g class=\"bar-group\">\n  {#each $data as d, i}\n    <rect\n      class='group-rect'\n      data-id=\"{i}\"\n      x=\"{$xScale.range()[0]}\"\n      y=\"{$yGet(d)}\"\n      height={$yScale.bandwidth()}\n      width=\"{$xGet(d)}\"\n      {fill}\n    ></rect>\n  {/each}\n</g>"},{"title":"./_components/AxisX.svelte","contents":"<!--\n  @component\n  Generates an SVG x-axis. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n -->\n<script>\n  import { getContext } from 'svelte';\n  const { width, height, xScale, yRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [baseline=false] â€“ Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapTicks=false] - Instead of centering the text on the first and the last items, align them to the edges of the chart. */\n  export let snapTicks = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [xTick=0] - TK */\n  export let xTick = 0;\n\n  /** @type {Number} [yTick=16] - The distance from the baseline to place each tick value. */\n  export let yTick = 16;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $xScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($xScale.ticks()) :\n          $xScale.ticks(ticks);\n\n  function textAnchor(i) {\n    if (snapTicks === true) {\n      if (i === 0) {\n        return 'start';\n      }\n      if (i === tickVals.length - 1) {\n        return 'end';\n      }\n    }\n    return 'middle';\n  }\n</script>\n\n<g class=\"axis x-axis\" class:snapTicks>\n  {#each tickVals as tick, i (tick)}\n    <g class=\"tick tick-{i}\" transform=\"translate({$xScale(tick)},{Math.max(...$yRange)})\">\n      {#if gridlines !== false}\n        <line class=\"gridline\" y1={$height * -1} y2=\"0\" x1=\"0\" x2=\"0\" />\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class=\"tick-mark\"\n          y1={0}\n          y2={6}\n          x1={xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\n          x2={xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\n        />\n      {/if}\n      <text\n        x={xTick || isBandwidth ? $xScale.bandwidth() / 2 : 0}\n        y={yTick}\n        dx=\"\"\n        dy=\"\"\n        text-anchor={textAnchor(i)}>{formatTick(tick)}</text\n      >\n    </g>\n  {/each}\n  {#if baseline === true}\n    <line class=\"baseline\" y1={$height + 0.5} y2={$height + 0.5} x1=\"0\" x2={$width} />\n  {/if}\n</g>\n\n<style>\n  .tick {\n    font-size: 0.725em;\n    font-weight: 200;\n  }\n\n  line,\n  .tick line {\n    stroke: #aaa;\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick .tick-mark,\n  .baseline {\n    stroke-dasharray: 0;\n  }\n  /* This looks slightly better */\n  .axis.snapTicks .tick:last-child text {\n    transform: translateX(3px);\n  }\n  .axis.snapTicks .tick.tick-0 text {\n    transform: translateX(-3px);\n  }\n</style>"},{"title":"./_components/AxisY.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { padding, xRange, yScale } = getContext('LayerCake');\n\n  /** @type {Boolean} [gridlines=true] - Extend lines from the ticks into the chart space */\n  export let gridlines = true;\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Function} [formatTick=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let formatTick = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [xTick=0] - How far over to position the text marker. */\n  export let xTick = 0;\n\n  /** @type {Number} [yTick=0] - How far up and down to position the text marker. */\n  export let yTick = 0;\n\n  /** @type {Number} [dxTick=0] - Any optional value passed to the `dx` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal. */\n  export let dxTick = 0;\n\n  /** @type {Number} [dyTick=-4] - Any optional value passed to the `dy` attribute on the text marker and tick mark (if visible). This is ignored on the text marker if your scale is ordinal. */\n  export let dyTick = -4;\n\n  /** @type {String} [textAnchor='start'] The CSS `text-anchor` passed to the label. This is automatically set to \"end\" if the scale has a bandwidth method, like in ordinal scales. */\n  export let textAnchor = 'start';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks) ? ticks :\n    isBandwidth ?\n      $yScale.domain() :\n      typeof ticks === 'function' ?\n        ticks($yScale.ticks()) :\n          $yScale.ticks(ticks);\n</script>\n\n<g class='axis y-axis' transform='translate({-$padding.left}, 0)'>\n  {#each tickVals as tick (tick)}\n    <g class='tick tick-{tick}' transform='translate({$xRange[0] + (isBandwidth ? $padding.left : 0)}, {$yScale(tick)})'>\n      {#if gridlines !== false}\n        <line\n          class=\"gridline\"\n          x2='100%'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      {#if tickMarks === true}\n        <line\n          class='tick-mark'\n          x1='0'\n          x2='{isBandwidth ? -6 : 6}'\n          y1={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n          y2={yTick + (isBandwidth ? ($yScale.bandwidth() / 2) : 0)}\n        ></line>\n      {/if}\n      <text\n        x='{xTick}'\n        y='{yTick + (isBandwidth ? $yScale.bandwidth() / 2 : 0)}'\n        dx='{isBandwidth ? -9 : dxTick}'\n        dy='{isBandwidth ? 4 : dyTick}'\n        style=\"text-anchor:{isBandwidth ? 'end' : textAnchor};\"\n      >{formatTick(tick)}</text>\n    </g>\n  {/each}\n</g>\n\n<style>\n  .tick {\n    font-size: .725em;\n    font-weight: 200;\n  }\n\n  .tick line {\n    stroke: #aaa;\n  }\n  .tick .gridline {\n    stroke-dasharray: 2;\n  }\n\n  .tick text {\n    fill: #666;\n  }\n\n  .tick.tick-0 line {\n    stroke-dasharray: 0;\n  }\n</style>"}],"modules":[],"componentModules":[],"componentComponents":[],"csvs":[{"title":"./_data/groups.csv","contents":"year,value\n1979,2\n1980,3\n1981,5\n1982,8\n1983,18"}],"jsons":[]}