{"main":{"title":"+page.svelte","contents":"<script>\n  import { LayerCake, Svg, ScaledSvg, Html } from 'layercake';\n  import { scaleBand } from 'd3-scale';\n\n  import Column from './_components/Column.svelte';\n  import AxisX from './_components/AxisX.percent-range.html.svelte';\n  import AxisY from './_components/AxisY.percent-range.html.svelte';\n  import Annotations from './_components/AnnotationsData.html.svelte';\n  import Arrows from './_components/Arrows.svelte';\n  import ArrowheadMarker from './_components/ArrowheadMarker.svelte';\n\n  // This example loads csv data as json using @rollup/plugin-dsv\n  import data from './_data/groups.csv';\n\n  const xKey = 'year';\n  const yKey = 'value';\n\n  const annotations = [\n    {\n      text: 'Example text...',\n      [xKey]: '1980',\n      [yKey]: 14,\n      dx: 15, // Optional pixel values\n      dy: -5,\n      arrows: [\n        {\n          clockwise: false, // true or false, defaults to true\n          source: {\n            anchor: 'left-bottom', // can be `{left, middle, right},{top-middle-bottom}`\n            dx: -2,\n            dy: -7\n          },\n          target: {\n            // These can be expressed in our data units if passed under the data keys\n            [xKey]: '1980',\n            [yKey]: 4.5,\n            // Optional adjustments\n            dx: 2,\n            dy: 5\n          }\n        },\n        {\n          source: {\n            anchor: 'right-bottom',\n            dy: -7,\n            dx: 5\n          },\n          target: {\n            // Or if they are percentage strings they can be passed directly\n            x: '68%',\n            y: '48%'\n          }\n        }\n      ]\n    }\n  ];\n\n  data.forEach(d => {\n    d[yKey] = +d[yKey];\n  });\n</script>\n\n<div class=\"chart-container\">\n  <LayerCake\n    ssr\n    percentRange\n    position=\"absolute\"\n    padding={{ top: 0, right: 0, bottom: 20, left: 20 }}\n    x={xKey}\n    y={yKey}\n    xScale={scaleBand().paddingInner(0.028).round(true)}\n    xDomain={['1979', '1980', '1981', '1982', '1983']}\n    yDomain={[0, null]}\n    {data}\n  >\n    <ScaledSvg>\n      <Column />\n    </ScaledSvg>\n\n    <Html>\n      <AxisX gridlines={false} />\n      <AxisY gridlines={false} snapBaselineLabel />\n      <Annotations {annotations} />\n    </Html>\n  </LayerCake>\n\n  <!--\n    Add a second cake for the arrows that is rendered once the page is loaded\n    since the arrows are hard to draw within the viewbox\n  -->\n  <LayerCake\n    position=\"absolute\"\n    padding={{ top: 0, right: 0, bottom: 20, left: 20 }}\n    x={xKey}\n    y={yKey}\n    xScale={scaleBand().paddingInner(0.028).round(true)}\n    xDomain={['1979', '1980', '1981', '1982', '1983']}\n    yDomain={[0, null]}\n    {data}\n  >\n    <Svg>\n      <svelte:fragment slot=\"defs\">\n        <ArrowheadMarker />\n      </svelte:fragment>\n      <Arrows {annotations} />\n    </Svg>\n  </LayerCake>\n</div>\n\n<style>\n  .chart-container {\n    width: 100%;\n    height: 400px;\n    position: relative;\n  }\n</style>"},"dek":"Since we want an ordinal x-axis and Layer Cake defaults to a linear scale, pass in a custom scale to `xScale` with a few formatting options. Set the y-scale to always start at `0` so you don't show misleading differences between groups.\n\nSince it's tricky to server-side render circles in SVG, this example uses a second `<LayerCake>` component for the arrow, which renders client-side and uses the `position='absolute'` prop to make sure the two cakes are super-imposed on one another.\n\nFor the annotation arrowhead, note that you may need to provide an [explicit link to your SVG marker id](https://github.com/sveltejs/svelte/issues/3450), such as in `./_components/Arrows.svelte` using `window.location.href`.\n","components":[{"title":"./_components/Column.svelte","contents":"<!--\n  @component\n  Generates an SVG column chart.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, x, yRange, xScale, y, height } = getContext('LayerCake');\n\n  /** @type {String} [fill='#00e047'] - The shape's fill color. */\n  export let fill = '#00e047';\n\n  /** @type {String} [stroke='#000'] - The shape's stroke color. */\n  export let stroke = '#000';\n\n  /** @type {Number} [strokeWidth=0] - The shape's stroke width. */\n  export let strokeWidth = 0;\n\n  /** @type {Boolean} [false] - Show the numbers for each column */\n  export let showLabels = false;\n\n  $: columnWidth = d => {\n    const vals = $xGet(d);\n    return Math.abs(vals[1] - vals[0]);\n  };\n\n  $: columnHeight = d => {\n    return $yRange[0] - $yGet(d);\n  };\n</script>\n\n<g class=\"column-group\">\n  {#each $data as d, i}\n    {@const colHeight = columnHeight(d)}\n    {@const xGot = $xGet(d)}\n    {@const xPos = Array.isArray(xGot) ? xGot[0] : xGot}\n    {@const colWidth = $xScale.bandwidth ? $xScale.bandwidth() : columnWidth(d)}\n    {@const yValue = $y(d)}\n    <rect\n      class=\"group-rect\"\n      data-id={i}\n      data-range={$x(d)}\n      data-count={yValue}\n      x={xPos}\n      y={$yGet(d)}\n      width={colWidth}\n      height={colHeight}\n      {fill}\n      {stroke}\n      stroke-width={strokeWidth}\n    />\n    {#if showLabels && yValue}\n      <text x={xPos + colWidth / 2} y={$height - colHeight - 5} text-anchor=\"middle\">{yValue}</text>\n    {/if}\n  {/each}\n</g>\n\n<style>\n  text {\n    font-size: 12px;\n  }\n</style>"},{"title":"./_components/AxisX.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML x-axis, useful for server-side rendered charts. This component is also configured to detect if your x-scale is an ordinal scale. If so, it will place the markers in the middle of the bandwidth.\n\n  Although this is marked as a percent-range component, you can also use it with a normal scale with no configuration needed. By default, if you have `percentRange={true}` it will use percentages, otherwise it will use pixels. This makes this component compatible with server-side and client-side rendered charts. Set the `units` prop to either `'%'` or `'px'` to override the default behavior.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xScale, percentRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show a vertical mark for each tick. */\n  export let tickMarks = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=6] - The length of the tick mark. */\n  export let tickMarkLength = 6;\n\n  /** @type {Boolean} [baseline=false] â€“ Show a solid line at the bottom. */\n  export let baseline = false;\n\n  /** @type {Boolean} [snapLabels=false] - Instead of centering the text labels on the first and the last items, align them to the edges of the chart. */\n  export let snapLabels = false;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. If nothing, it uses the default ticks supplied by the D3 function. */\n  export let ticks = undefined;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the yRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=0] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = 0;\n\n  /** @type {String} units - Whether this component should use percentage or pixel values. If `percentRange={true}` it defaults to `'%'`. Options: `'%'` or `'px'`. */\n  export let units = $percentRange === true ? '%' : 'px';\n\n  $: tickLen = tickMarks === true ? tickMarkLength ?? 6 : 0;\n\n  $: isBandwidth = typeof $xScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $xScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($xScale.ticks())\n        : $xScale.ticks(ticks);\n\n  $: halfBand = isBandwidth ? $xScale.bandwidth() / 2 : 0;\n</script>\n\n<div class=\"axis x-axis\" class:snapLabels>\n  {#each tickVals as tick, i (tick)}\n    {@const tickValUnits = $xScale(tick)}\n\n    {#if baseline === true}\n      <div class=\"baseline\" style=\"top:100%; width:100%;\"></div>\n    {/if}\n\n    {#if gridlines === true}\n      <div class=\"gridline\" style:left=\"{tickValUnits}{units}\" style=\"top:0; bottom:0;\"></div>\n    {/if}\n    {#if tickMarks === true}\n      <div\n        class=\"tick-mark\"\n        style:left=\"{tickValUnits + halfBand}{units}\"\n        style:height=\"{tickLen}px\"\n        style:bottom=\"{-tickLen - tickGutter}px\"\n      ></div>\n    {/if}\n    <div\n      class=\"tick tick-{i}\"\n      style:left=\"{tickValUnits + halfBand}{units}\"\n      style=\"top:calc(100% + {tickGutter}px);\"\n    >\n      <div\n        class=\"text\"\n        style:top=\"{tickLen}px\"\n        style:transform=\"translate(calc(-50% + {dx}px), {dy}px)\"\n      >\n        {format(tick)}\n      </div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n  }\n\n  .gridline {\n    border-left: 1px dashed #aaa;\n  }\n\n  .tick-mark {\n    border-left: 1px solid #aaa;\n  }\n  .baseline {\n    border-top: 1px solid #aaa;\n  }\n\n  .tick .text {\n    color: #666;\n    position: relative;\n    white-space: nowrap;\n    transform: translateX(-50%);\n  }\n  /* This looks a little better at 40 percent than 50 */\n  .axis.snapLabels .tick:last-child {\n    transform: translateX(-40%);\n  }\n  .axis.snapLabels .tick.tick-0 {\n    transform: translateX(40%);\n  }\n</style>"},{"title":"./_components/AxisY.percent-range.html.svelte","contents":"<!--\n  @component\n  Generates an HTML y-axis. This component is also configured to detect if your y-scale is an ordinal scale. If so, it will place the tickMarks in the middle of the bandwidth.\n\n  Although this is marked as a percent-range component, you can also use it with a normal scale with no configuration needed. By default, if you have `percentRange={true}` it will use percentages, otherwise it will use pixels. This makes this component compatible with server-side and client-side rendered charts. Set the `units` prop to either `'%'` or `'px'` to override the default behavior.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xRange, yScale, percentRange } = getContext('LayerCake');\n\n  /** @type {Boolean} [tickMarks=false] - Show marks next to the tick label. */\n  export let tickMarks = false;\n\n  /** @type {String} [labelPosition='even'] - Whether the label sits even with its value ('even') or sits on top ('above') the tick mark. Default is 'even'. */\n  export let labelPosition = 'even';\n\n  /** @type {Boolean} [snapBaselineLabel=false] - When labelPosition='even', adjust the lowest label so that it sits above the tick mark. */\n  export let snapBaselineLabel = false;\n\n  /** @type {Boolean} [gridlines=true] - Show gridlines extending into the chart area. */\n  export let gridlines = true;\n\n  /** @type {Number} [tickMarkLength=undefined] - The length of the tick mark. If not set, becomes the length of the widest tick. */\n  export let tickMarkLength = undefined;\n\n  /** @type {Function} [format=d => d] - A function that passes the current tick value and expects a nicely formatted value in return. */\n  export let format = d => d;\n\n  /** @type {Number|Array|Function} [ticks=4] - If this is a number, it passes that along to the [d3Scale.ticks](https://github.com/d3/d3-scale) function. If this is an array, hardcodes the ticks to those values. If it's a function, passes along the default tick values and expects an array of tick values in return. */\n  export let ticks = 4;\n\n  /** @type {Number} [tickGutter=0] - The amount of whitespace between the start of the tick and the chart drawing area (the xRange min). */\n  export let tickGutter = 0;\n\n  /** @type {Number} [dx=0] - Any optional value passed to the `dx` attribute on the text label. */\n  export let dx = 0;\n\n  /** @type {Number} [dy=-3] - Any optional value passed to the `dy` attribute on the text label. */\n  export let dy = -3;\n\n  /** @type {Number} [charPixelWidth=7.25] - Used to calculate the widest label length to offset labels. Adjust if the automatic tick length doesn't look right because you have a bigger font (or just set `tickMarkLength` to a pixel value). */\n  export let charPixelWidth = 7.25;\n\n  /** @type {String} units - Whether this component should use percentage or pixel values. If `percentRange={true}` it defaults to `'%'`. Options: `'%'` or `'px'`. */\n  export let units = $percentRange === true ? '%' : 'px';\n\n  $: isBandwidth = typeof $yScale.bandwidth === 'function';\n\n  $: tickVals = Array.isArray(ticks)\n    ? ticks\n    : isBandwidth\n      ? $yScale.domain()\n      : typeof ticks === 'function'\n        ? ticks($yScale.ticks())\n        : $yScale.ticks(ticks);\n\n  function calcStringLength(sum, val) {\n    if (val === ',' || val === '.') return sum + charPixelWidth * 0.5;\n    return sum + charPixelWidth;\n  }\n\n  $: tickLen =\n    tickMarks === true\n      ? labelPosition === 'above'\n        ? tickMarkLength ?? widestTickLen\n        : tickMarkLength ?? 6\n      : 0;\n\n  $: widestTickLen = Math.max(\n    10,\n    Math.max(...tickVals.map(d => format(d).toString().split('').reduce(calcStringLength, 0)))\n  );\n\n  $: x1 = -tickGutter - (labelPosition === 'above' ? widestTickLen : tickLen);\n  $: halfBand = isBandwidth ? $yScale.bandwidth() / 2 : 0;\n\n  $: maxTickValUnits = Math.max(...tickVals.map($yScale));\n</script>\n\n<div class=\"axis y-axis\">\n  {#each tickVals as tick, i (tick)}\n    {@const tickValUnits = $yScale(tick)}\n\n    <div\n      class=\"tick tick-{i}\"\n      style=\"left:{$xRange[0]}{units};top:{tickValUnits + halfBand}{units};\"\n    >\n      {#if gridlines === true}\n        <div class=\"gridline\" style=\"top:0;\" style:left=\"{x1}px\" style:right=\"0px\"></div>\n      {/if}\n      {#if tickMarks === true}\n        <div class=\"tick-mark\" style:top=\"0\" style:left=\"{x1}px\" style:width=\"{tickLen}px\"></div>\n      {/if}\n      <div\n        class=\"text\"\n        style:top=\"0\"\n        style:text-align={labelPosition === 'even' ? 'right' : 'left'}\n        style:width=\"{widestTickLen}px\"\n        style:left=\"{-widestTickLen - tickGutter - (labelPosition === 'even' ? tickLen : 0)}px\"\n        style:transform=\"translate({dx + (labelPosition === 'even' ? -3 : 0)}px, calc(-50% + {dy +\n          (labelPosition === 'above' ||\n          (snapBaselineLabel === true && tickValUnits === maxTickValUnits)\n            ? -3\n            : 4)}px))\"\n      >\n        {format(tick)}\n      </div>\n    </div>\n  {/each}\n</div>\n\n<style>\n  .axis,\n  .tick,\n  .tick-mark,\n  .gridline,\n  .baseline,\n  .text {\n    position: absolute;\n  }\n  .axis {\n    width: 100%;\n    height: 100%;\n  }\n  .tick {\n    font-size: 11px;\n    width: 100%;\n  }\n\n  .gridline {\n    border-top: 1px dashed #aaa;\n  }\n  .tick-mark {\n    border-top: 1px solid #aaa;\n  }\n\n  .baseline.gridline {\n    border-top-style: solid;\n  }\n\n  .tick .text {\n    color: #666;\n  }\n</style>"},{"title":"./_components/AnnotationsData.html.svelte","contents":"<!--\n  @component\n  Adds text annotations that get their x and y placement using the `xScale` and `yScale`.\n -->\n<script>\n  import { getContext } from 'svelte';\n\n  const { xGet, yGet, percentRange } = getContext('LayerCake');\n\n  /** @type {Array} annotations - A list of annotation objects. */\n  export let annotations = [];\n\n  /** @type {Function} [getText=d => d.text] - An accessor function to get the field to display. */\n  export let getText = d => d.text;\n\n  /** @type {Boolean} [percentRange=false] - If `true` will set the `top` and `left` CSS positions to percentages instead of pixels. */\n  export let pr = $percentRange;\n\n  $: units = pr === true ? '%' : 'px';\n</script>\n\n<div class=\"layercake-annotations\">\n  {#each annotations as d, i}\n    <div\n      class=\"layercake-annotation\"\n      data-id={i}\n      style:left={`calc(${$xGet(d)}${units} + ${d.dx || 0}px)`}\n      style:top={`calc(${$yGet(d)}${units} + ${d.dy || 0}px)`}\n    >\n      {getText(d)}\n    </div>\n  {/each}\n</div>\n\n<style>\n  .layercake-annotation {\n    position: absolute;\n  }\n</style>"},{"title":"./_components/Arrows.svelte","contents":"<!--\n  @component\n  Adds SVG swoopy arrows based on a config object. It attaches arrows to divs, which are created by another component such as [Annotations.html.svelte](https://layercake.graphics/components/Annotations.html.svelte).\n -->\n<script>\n  import { getContext, onMount, tick } from 'svelte';\n  import { swoopyArrow, getElPosition, parseCssValue } from '../_modules/arrowUtils.js';\n\n  /** @type {Array} annotations - A list of annotation objects. See the [Column](https://layercake.graphics/example/Column) chart example for the schema and options. */\n  export let annotations = [];\n\n  /** @type {String} [annotationClass='.layercake-annotation'] - The class name of the text annotation divs. */\n  export let containerClass = '.chart-container';\n\n  /** @type {String} [containerClass='.chart-container'] - The class name / CSS selector of the parent element of the `<LayerCake>` component. This is used to crawl the DOM for the text annotations. */\n  export let annotationClass = '.layercake-annotation';\n\n  let container;\n\n  const { width, height, xScale, yScale, x, y } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Some lookups to convert between x, y / width, height terminology\n   * and CSS names\n   */\n  const lookups = [\n    { dimension: 'width', css: 'left', position: 'x' },\n    { dimension: 'height', css: 'top', position: 'y' }\n  ];\n\n  let d = () => '';\n  let annotationEls;\n\n  // This searches the DOM for the HTML annotations\n  // in the Annotations.svelte componenent and then\n  // attaches arrows to those divs\n  // Make sure the `.chart-container` and `.layercake-annotation`\n  // selectors match what you have in your project\n  // otherwise it won't find anything\n  onMount(async () => {\n    await tick();\n    annotationEls = Array.from(container.closest(containerClass).querySelectorAll(annotationClass));\n  });\n\n  function setPath(w, h) {\n    return (anno, i, arrow) => {\n      const el = annotationEls[i];\n\n      /* --------------------------------------------\n       * Parse our attachment directives to know where to start the arrowhead\n       * measuring a bounding box based on our annotation el\n       */\n      const arrowSource = getElPosition(el);\n      const sourceCoords = arrow.source.anchor.split('-').map((q, j) => {\n        const point =\n          q === 'middle'\n            ? arrowSource[lookups[j].css] + arrowSource[lookups[j].dimension] / 2\n            : arrowSource[q];\n        return (\n          point +\n          parseCssValue(\n            arrow.source[`d${lookups[j].position}`],\n            i,\n            arrowSource.width,\n            arrowSource.height\n          )\n        );\n      });\n\n      /* --------------------------------------------\n       * Default to clockwise\n       */\n      const clockwise = typeof arrow.clockwise === 'undefined' ? true : arrow.clockwise;\n\n      /* --------------------------------------------\n       * Parse where we're drawing to\n       * If we're passing in a percentage as a string then we need to convert it to pixel values\n       * Otherwise pass it to our xGet and yGet functions\n       */\n      const targetCoords = [\n        arrow.target.x || $x(arrow.target),\n        arrow.target.y || $y(arrow.target)\n      ].map((q, j) => {\n        const val =\n          typeof q === 'string' && q.includes('%')\n            ? parseCssValue(q, j, w, h)\n            : j\n              ? $yScale(q)\n              : $xScale(q);\n        return val + (arrow.target[`d${lookups[j].position}`] || 0);\n      });\n\n      /* --------------------------------------------\n       * Create arrow path\n       */\n      return swoopyArrow()\n        .angle(Math.PI / 2)\n        .clockwise(clockwise)\n        .x(q => q[0])\n        .y(q => q[1])([sourceCoords, targetCoords]);\n    };\n  }\n\n  $: if (annotationEls && annotationEls.length) d = setPath($width, $height);\n</script>\n\n<g bind:this={container}>\n  {#if annotations.length}\n    <g class=\"swoops\">\n      {#each annotations as anno, i}\n        {#if anno.arrows}\n          {#each anno.arrows as arrow}\n            <path marker-end=\"url(#arrowhead)\" d={d(anno, i, arrow)}></path>\n          {/each}\n        {/if}\n      {/each}\n    </g>\n  {/if}\n</g>\n\n<style>\n  .swoops {\n    position: absolute;\n    max-width: 200px;\n    line-height: 14px;\n  }\n  .swoops path {\n    fill: none;\n    stroke: #000;\n    stroke-width: 1;\n  }\n</style>"},{"title":"./_components/ArrowheadMarker.svelte","contents":"<!--\n  @component\n  Generates an SVG marker containing a marker for a triangle makes a nice arrowhead. Add it to the named slot called \"defs\" on the SVG layout component.\n -->\n<script>\n  /** @type {String} [fill='#000'] â€“ The arrowhead's fill color. */\n  export let fill = '#000';\n\n  /** @type {String} [stroke='#000'] â€“ The arrowhead's fill color. */\n  export let stroke = '#000';\n</script>\n\n<marker id=\"arrowhead\" viewBox=\"-10 -10 20 20\" markerWidth=\"17\" markerHeight=\"17\" orient=\"auto\">\n  <path d=\"M-6,-6 L 0,0 L -6,6\" {fill} {stroke} />\n</marker>"}],"modules":[],"componentModules":[{"title":"./_modules/arrowUtils.js","contents":"// Helper functions for creating swoopy arrows\n\n/* --------------------------------------------\n * parseCssValue\n *\n * Parse various inputs and return then as a number\n * Can be a number, which will return the input value\n * A percentage, which will take the percent of the appropriate dimentions\n * A pixel value, which will parse as a number\n *\n */\nexport function parseCssValue(d, i, width, height) {\n  if (!d) return 0;\n  if (typeof d === 'number') {\n    return d;\n  }\n  if (d.indexOf('%') > -1) {\n    return (+d.replace('%', '') / 100) * (i ? height : width);\n  }\n  return +d.replace('px', '');\n}\n\n/* --------------------------------------------\n * getElPosition\n *\n * Constract a bounding box relative in our coordinate space\n * that we can attach arrow starting points to\n *\n */\nexport function getElPosition(el) {\n  const annotationBbox = el.getBoundingClientRect();\n  const parentBbox = el.parentNode.getBoundingClientRect();\n  const coords = {\n    top: annotationBbox.top - parentBbox.top,\n    right: annotationBbox.right - parentBbox.left,\n    bottom: annotationBbox.bottom - parentBbox.top,\n    left: annotationBbox.left - parentBbox.left,\n    width: annotationBbox.width,\n    height: annotationBbox.height\n  };\n  return coords;\n}\n\n/* --------------------------------------------\n * swoopyArrow\n *\n * Adapted from bizweekgraphics/swoopyarrows\n *\n */\nexport function swoopyArrow() {\n  let angle = Math.PI;\n  let clockwise = true;\n  let xValue = d => d[0];\n  let yValue = d => d[1];\n\n  function hypotenuse(a, b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  }\n\n  function render(data) {\n    data = data.map((d, i) => {\n      return [xValue.call(data, d, i), yValue.call(data, d, i)];\n    });\n\n    // get the chord length (\"height\" {h}) between points\n    const h = hypotenuse(data[1][0] - data[0][0], data[1][1] - data[0][1]);\n\n    // get the distance at which chord of height h subtends {angle} radians\n    const d = h / (2 * Math.tan(angle / 2));\n\n    // get the radius {r} of the circumscribed circle\n    const r = hypotenuse(d, h / 2);\n\n    /*\n    SECOND, compose the corresponding SVG arc.\n      read up: http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n      example: <path d = \"M 200,50 a 50,50 0 0,1 100,0\"/>\n                          M 200,50                          Moves pen to (200,50);\n                                   a                        draws elliptical arc;\n                                     50,50                  following a degenerate ellipse, r1 == r2 == 50;\n                                                            i.e. a circle of radius 50;\n                                           0                with no x-axis-rotation (irrelevant for circles);\n                                             0,1            with large-axis-flag=0 and sweep-flag=1 (clockwise);\n                                                 100,0      to a point +100 in x and +0 in y, i.e. (300,50).\n    */\n    const path =\n      'M ' +\n      data[0][0] +\n      ',' +\n      data[0][1] +\n      ' a ' +\n      r +\n      ',' +\n      r +\n      ' 0 0,' +\n      (clockwise ? '1' : '0') +\n      ' ' +\n      (data[1][0] - data[0][0]) +\n      ',' +\n      (data[1][1] - data[0][1]);\n\n    return path;\n  }\n\n  render.angle = function renderAngle(_) {\n    if (!arguments.length) return angle;\n    angle = Math.min(Math.max(_, 1e-6), Math.PI - 1e-6);\n    return render;\n  };\n\n  render.clockwise = function renderClockwise(_) {\n    if (!arguments.length) return clockwise;\n    clockwise = !!_;\n    return render;\n  };\n\n  render.x = function renderX(_) {\n    if (!arguments.length) return xValue;\n    xValue = _;\n    return render;\n  };\n\n  render.y = function renderY(_) {\n    if (!arguments.length) return yValue;\n    yValue = _;\n    return render;\n  };\n\n  return render;\n}"}],"componentComponents":[],"csvs":[{"title":"./_data/groups.csv","contents":"year,value\n1979,2\n1980,3\n1981,5\n1982,8\n1983,18"}],"jsons":[]}