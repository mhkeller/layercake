{"main":{"slug":"Scatter.webgl.svelte","contents":"<!--\n  @component\n  Generates a a WebGl scatter plot.\n -->\n<script>\n  import reglWrapper from 'regl';\n  import { getContext } from 'svelte';\n\n  const { data, xGet, yGet, width, height } = getContext('LayerCake');\n\n  /** @type {Number} [r=5] - The circle's radius. */\n  export let r = 5;\n\n  /** @type {String} [fill='#0cf'] - The circle's fill color. */\n  export let fill = '#0cf';\n\n  export let stroke = '#000'; // Not yet implemented\n  // export let strokeWidth = 0;\n\n  function hexToRgbPercent(hex) {\n    let str = hex.replace('#', '');\n    if (str.length === 3) {\n      str = str[0] + str[0] + str[1] + str[1] + str[2] + str[2];\n    }\n    return str.match(/.{1,2}/g).map(d => parseInt(d, 16) / 255);\n  }\n\n  const { gl } = getContext('gl');\n\n  function resize() {\n    if ($gl) {\n      const canvas = $gl.canvas;\n      // Lookup the size the browser is displaying the canvas.\n      const displayWidth = canvas.clientWidth;\n      const displayHeight = canvas.clientHeight;\n\n      // Check if the canvas is not the same size.\n      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n        // Make the canvas the same size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n      }\n      $gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n  }\n\n  let regl;\n\n  function render() {\n    if ($gl) {\n      regl = reglWrapper({\n        gl: $gl,\n        extensions: ['oes_standard_derivatives']\n      });\n\n      regl.clear({\n        color: [0, 0, 0, 0],\n        depth: 1\n      });\n\n      const draw = regl({\n        // circle code comes from:\n        // https://www.desultoryquest.com/blog/drawing-anti-aliased-circular-points-using-opengl-slash-webgl/\n        frag: `\n        #extension GL_OES_standard_derivatives : enable\n        precision mediump float;\n        uniform vec3 fill_color;\n        uniform vec3 stroke_color;\n        varying float s_s;\n        void main () {\n\n          vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\n          float dist = dot(cxy, cxy);\n\n          float delta = fwidth(dist);\n\n          float alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, dist);\n\n          float outer_edge_center = 1.0 - s_s;\n          float stroke = 1.0 - smoothstep(outer_edge_center - delta, outer_edge_center + delta, dist);\n\n          // gl_FragColor = vec4(fill_color,1.0) * alpha;\n          gl_FragColor = vec4( mix(stroke_color, fill_color, stroke), 1.0 ) * alpha;\n          gl_FragColor.rgb *= gl_FragColor.a;\n        }`,\n        vert: `\n        precision mediump float;\n        attribute vec2 position;\n        attribute float r;\n        attribute float stroke_size;\n\n        varying float s_s;\n\n        uniform float stage_width;\n        uniform float stage_height;\n\n        // http://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html\n        vec2 normalizeCoords(vec2 position) {\n          // read in the positions into x and y vars\n          float x = position[0];\n          float y = position[1];\n          return vec2(\n            2.0 * ((x / stage_width) - 0.5),\n            // invert y to treat [0,0] as bottom left in pixel space\n            -(2.0 * ((y / stage_height) - 0.5))\n          );\n        }\n\n        void main () {\n          s_s = stroke_size;\n          gl_PointSize = r;\n          gl_Position = vec4(normalizeCoords(position), 0.0, 1.0);\n        }`,\n        attributes: {\n          // There will be a position value for each point\n          // we pass in\n          position: (context, props) => {\n            return props.points.map(point => {\n              return [$xGet(point), $yGet(point)];\n            });\n          },\n          r: (context, props) => {\n            // const m = window.devicePixelRatio > 1 ? 4.0 : 2.0\n            // If using an r-scale, set width here\n            return props.points.map(p => props.pointWidth);\n          },\n          stroke_size: (context, props) => {\n            // If using an r-scale, set that here\n            return props.points.map(p => 0);\n          }\n        },\n        uniforms: {\n          fill_color: hexToRgbPercent(fill),\n          // stroke_color: [0.6705882352941176, 0, 0.8392156862745098],\n          stroke_color: hexToRgbPercent(stroke),\n          // FYI: there is a helper method for grabbing\n          // values out of the context as well.\n          // These uniforms are used in our fragment shader to\n          // convert our x / y values to WebGL coordinate space.\n          stage_width: regl.context('drawingBufferWidth'),\n          stage_height: regl.context('drawingBufferHeight')\n        },\n        count: (context, props) => {\n          // set the count based on the number of points we have\n          return props.points.length;\n        },\n        primitive: 'points',\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: 'src alpha',\n            srcAlpha: 'src alpha',\n            dstRGB: 'one minus src alpha',\n            dstAlpha: 'one minus src alpha'\n          }\n        },\n        depth: { enable: false }\n      });\n\n      draw({\n        pointWidth: r * 2,\n        points: $data\n      });\n    }\n  }\n\n  $: $width, $height, $gl, resize(), render();\n</script>"},"dek":"","usedIn":[{"group":"Regular","matches":["/example/ScatterWebgl"]},{"group":"SSR","matches":["/example-ssr/ScatterWebgl"]}],"hasjsDoctable":true,"jsdocParsed":{"description":"","tags":[{"title":"param","description":"The circle's radius.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"Number"}},"name":"r","default":"5"},{"title":"param","description":"The circle's fill color.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"String"}},"name":"fill","default":"'#0cf'"}]},"componentDescription":"Generates a a WebGl scatter plot.","modules":[]}