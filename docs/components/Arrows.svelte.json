{"main":{"slug":"Arrows.svelte","contents":"<!--\n  @component\n  Adds SVG swoopy arrows based on a config object. It attaches arrows to divs, which are created by another component such as [Annotations.html.svelte](https://layercake.graphics/components/Annotations.html.svelte).\n -->\n<script>\n  import { getContext, onMount, tick } from 'svelte';\n  import { swoopyArrow, getElPosition, parseCssValue } from '../_modules/arrowUtils.js';\n\n  /** @type {Array} annotations - A list of annotation objects. See the [Column](https://layercake.graphics/example/Column) chart example for the schema and options. */\n  export let annotations = [];\n\n  /** @type {String} [annotationClass='.layercake-annotation'] - The class name of the text annotation divs. */\n  export let containerClass = '.chart-container';\n\n  /** @type {String} [containerClass='.chart-container'] - The class name / CSS selector of the parent element of the `<LayerCake>` component. This is used to crawl the DOM for the text annotations. */\n  export let annotationClass = '.layercake-annotation';\n\n  let container;\n\n  const { width, height, xScale, yScale, x, y } = getContext('LayerCake');\n\n  /* --------------------------------------------\n   * Some lookups to convert between x, y / width, height terminology\n   * and CSS names\n   */\n  const lookups = [\n    { dimension: 'width', css: 'left', position: 'x' },\n    { dimension: 'height', css: 'top', position: 'y' }\n  ];\n\n  let d = () => '';\n  let annotationEls;\n\n  // This searches the DOM for the HTML annotations\n  // in the Annotations.svelte componenent and then\n  // attaches arrows to those divs\n  // Make sure the `.chart-container` and `.layercake-annotation`\n  // selectors match what you have in your project\n  // otherwise it won't find anything\n  onMount(async () => {\n    await tick();\n    annotationEls = Array.from(container.closest(containerClass).querySelectorAll(annotationClass));\n  });\n\n  function setPath(w, h) {\n    return (anno, i, arrow) => {\n      const el = annotationEls[i];\n\n      /* --------------------------------------------\n       * Parse our attachment directives to know where to start the arrowhead\n       * measuring a bounding box based on our annotation el\n       */\n      const arrowSource = getElPosition(el);\n      const sourceCoords = arrow.source.anchor.split('-').map((q, j) => {\n        const point =\n          q === 'middle'\n            ? arrowSource[lookups[j].css] + arrowSource[lookups[j].dimension] / 2\n            : arrowSource[q];\n        return (\n          point +\n          parseCssValue(\n            arrow.source[`d${lookups[j].position}`],\n            i,\n            arrowSource.width,\n            arrowSource.height\n          )\n        );\n      });\n\n      /* --------------------------------------------\n       * Default to clockwise\n       */\n      const clockwise = typeof arrow.clockwise === 'undefined' ? true : arrow.clockwise;\n\n      /* --------------------------------------------\n       * Parse where we're drawing to\n       * If we're passing in a percentage as a string then we need to convert it to pixel values\n       * Otherwise pass it to our xGet and yGet functions\n       */\n      const targetCoords = [\n        arrow.target.x || $x(arrow.target),\n        arrow.target.y || $y(arrow.target)\n      ].map((q, j) => {\n        const val =\n          typeof q === 'string' && q.includes('%')\n            ? parseCssValue(q, j, w, h)\n            : j\n              ? $yScale(q)\n              : $xScale(q);\n        return val + (arrow.target[`d${lookups[j].position}`] || 0);\n      });\n\n      /* --------------------------------------------\n       * Create arrow path\n       */\n      return swoopyArrow()\n        .angle(Math.PI / 2)\n        .clockwise(clockwise)\n        .x(q => q[0])\n        .y(q => q[1])([sourceCoords, targetCoords]);\n    };\n  }\n\n  $: if (annotationEls && annotationEls.length) d = setPath($width, $height);\n</script>\n\n<g bind:this={container}>\n  {#if annotations.length}\n    <g class=\"swoops\">\n      {#each annotations as anno, i}\n        {#if anno.arrows}\n          {#each anno.arrows as arrow}\n            <path marker-end=\"url(#arrowhead)\" d={d(anno, i, arrow)}></path>\n          {/each}\n        {/if}\n      {/each}\n    </g>\n  {/if}\n</g>\n\n<style>\n  .swoops {\n    position: absolute;\n    max-width: 200px;\n    line-height: 14px;\n  }\n  .swoops path {\n    fill: none;\n    stroke: #000;\n    stroke-width: 1;\n  }\n</style>"},"dek":"","usedIn":[{"group":"Regular","matches":["/example/Column"]},{"group":"SSR","matches":["/example-ssr/Column"]}],"hasjsDoctable":true,"jsdocParsed":{"description":"","tags":[{"title":"param","description":"A list of annotation objects. See the [Column](https://layercake.graphics/example/Column) chart example for the schema and options.","type":{"type":"NameExpression","name":"Array"},"name":"annotations"},{"title":"param","description":"The class name of the text annotation divs.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"String"}},"name":"annotationClass","default":"'.layercake-annotation'"},{"title":"param","description":"The class name / CSS selector of the parent element of the `<LayerCake>` component. This is used to crawl the DOM for the text annotations.","type":{"type":"OptionalType","expression":{"type":"NameExpression","name":"String"}},"name":"containerClass","default":"'.chart-container'"}]},"componentDescription":"Adds SVG swoopy arrows based on a config object. It attaches arrows to divs, which are created by another component such as [Annotations.html.svelte](https://layercake.graphics/components/Annotations.html.svelte).","modules":[{"slug":"./_modules/arrowUtils.js","contents":"// Helper functions for creating swoopy arrows\n\n/* --------------------------------------------\n * parseCssValue\n *\n * Parse various inputs and return then as a number\n * Can be a number, which will return the input value\n * A percentage, which will take the percent of the appropriate dimentions\n * A pixel value, which will parse as a number\n *\n */\nexport function parseCssValue(d, i, width, height) {\n  if (!d) return 0;\n  if (typeof d === 'number') {\n    return d;\n  }\n  if (d.indexOf('%') > -1) {\n    return (+d.replace('%', '') / 100) * (i ? height : width);\n  }\n  return +d.replace('px', '');\n}\n\n/* --------------------------------------------\n * getElPosition\n *\n * Constract a bounding box relative in our coordinate space\n * that we can attach arrow starting points to\n *\n */\nexport function getElPosition(el) {\n  const annotationBbox = el.getBoundingClientRect();\n  const parentBbox = el.parentNode.getBoundingClientRect();\n  const coords = {\n    top: annotationBbox.top - parentBbox.top,\n    right: annotationBbox.right - parentBbox.left,\n    bottom: annotationBbox.bottom - parentBbox.top,\n    left: annotationBbox.left - parentBbox.left,\n    width: annotationBbox.width,\n    height: annotationBbox.height\n  };\n  return coords;\n}\n\n/* --------------------------------------------\n * swoopyArrow\n *\n * Adapted from bizweekgraphics/swoopyarrows\n *\n */\nexport function swoopyArrow() {\n  let angle = Math.PI;\n  let clockwise = true;\n  let xValue = d => d[0];\n  let yValue = d => d[1];\n\n  function hypotenuse(a, b) {\n    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n  }\n\n  function render(data) {\n    data = data.map((d, i) => {\n      return [xValue.call(data, d, i), yValue.call(data, d, i)];\n    });\n\n    // get the chord length (\"height\" {h}) between points\n    const h = hypotenuse(data[1][0] - data[0][0], data[1][1] - data[0][1]);\n\n    // get the distance at which chord of height h subtends {angle} radians\n    const d = h / (2 * Math.tan(angle / 2));\n\n    // get the radius {r} of the circumscribed circle\n    const r = hypotenuse(d, h / 2);\n\n    /*\n    SECOND, compose the corresponding SVG arc.\n      read up: http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n      example: <path d = \"M 200,50 a 50,50 0 0,1 100,0\"/>\n                          M 200,50                          Moves pen to (200,50);\n                                   a                        draws elliptical arc;\n                                     50,50                  following a degenerate ellipse, r1 == r2 == 50;\n                                                            i.e. a circle of radius 50;\n                                           0                with no x-axis-rotation (irrelevant for circles);\n                                             0,1            with large-axis-flag=0 and sweep-flag=1 (clockwise);\n                                                 100,0      to a point +100 in x and +0 in y, i.e. (300,50).\n    */\n    const path =\n      'M ' +\n      data[0][0] +\n      ',' +\n      data[0][1] +\n      ' a ' +\n      r +\n      ',' +\n      r +\n      ' 0 0,' +\n      (clockwise ? '1' : '0') +\n      ' ' +\n      (data[1][0] - data[0][0]) +\n      ',' +\n      (data[1][1] - data[0][1]);\n\n    return path;\n  }\n\n  render.angle = function renderAngle(_) {\n    if (!arguments.length) return angle;\n    angle = Math.min(Math.max(_, 1e-6), Math.PI - 1e-6);\n    return render;\n  };\n\n  render.clockwise = function renderClockwise(_) {\n    if (!arguments.length) return clockwise;\n    clockwise = !!_;\n    return render;\n  };\n\n  render.x = function renderX(_) {\n    if (!arguments.length) return xValue;\n    xValue = _;\n    return render;\n  };\n\n  render.y = function renderY(_) {\n    if (!arguments.length) return yValue;\n    yValue = _;\n    return render;\n  };\n\n  return render;\n}"}]}